<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025年3月12日hot100练习</title>
    <link href="/2025/03/13/20250312-hot100/"/>
    <url>/2025/03/13/20250312-hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br>示例1：<br>输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,8,0,7]<br>示例2：<br>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[8,0,7]<br>示例3：<br>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    ListNode* next;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-built_in">ListNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>():<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        ListNode* nex = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur)<br>        &#123;<br>            nex = cur-&gt;next;<br><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;   <br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoListByCarry</span><span class="hljs-params">(ListNode* a,ListNode* b,<span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-literal">nullptr</span> &amp;&amp; b == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> carry?<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry):<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(a-&gt;next) <span class="hljs-built_in">swap</span>(a,b);<br><br>        carry += a-&gt;val + b?b-&gt;val:<span class="hljs-number">0</span>;<br>        a-&gt;val = carry % <span class="hljs-number">10</span>;<br>        a-&gt;next = <span class="hljs-built_in">mergeTwoListByCarry</span>(a-&gt;next,b?b-&gt;next:<span class="hljs-literal">nullptr</span>,carry/<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* nl1 = <span class="hljs-built_in">reverseList</span>(l1);<br>        ListNode* nl2 = <span class="hljs-built_in">reverseList</span>(l2);<br>        ListNode* res = <span class="hljs-built_in">mergeTwoListByCarry</span>(ListNode* a,ListNode* b,<span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个大小为<code>m x n</code>的二进制矩阵 grid 。岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的<code>「相邻」</code>要求两个 1 必须在<code>水平或者竖直的四个方向上</code>相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。<br>示例一：<br>输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>输出：6<br>解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flag,<span class="hljs-type">int</span>&amp; curArea)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> row = x + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> col = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(row&gt;=<span class="hljs-number">0</span> &amp;&amp; row&lt;grid.<span class="hljs-built_in">size</span>() &amp;&amp; col&gt;=<span class="hljs-number">0</span> &amp;&amp; col&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[row][col])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(flag[row][col] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                flag[row][col] = <span class="hljs-number">1</span>;<br>                curArea++;<br>                <span class="hljs-built_in">bfs</span>(grid,row,col,flag,curArea);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">flag</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(flag[i][j] == <span class="hljs-number">0</span> &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>)<br>                &#123;<br>                    flag[i][j] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> curArea = <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">bfs</span>(grid,i,j,flag,curArea);<br>                    maxArea = <span class="hljs-built_in">max</span>(maxArea,curArea);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。</p><h2 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || (x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> &amp;&amp; x!=<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> origin = x;<br>       <span class="hljs-keyword">while</span>(x&gt;reverse)<br>       &#123;<br>            <span class="hljs-type">int</span> digit = x%<span class="hljs-number">10</span>;<br>            reverse = reverse*<span class="hljs-number">10</span> + digit;<br>            x/=<span class="hljs-number">10</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> x == reverse || x == reverse / <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><h2 id="代码编写：-2"><a href="#代码编写：-2" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(que.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> sz = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; array;<br>            <span class="hljs-keyword">while</span>(sz--)<br>            &#123;<br>                TreeNode* cur = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                array.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(array);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode-hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月12日网络编程八股文</title>
    <link href="/2025/03/12/interByCpp/"/>
    <url>/2025/03/12/interByCpp/</url>
    
    <content type="html"><![CDATA[<h1 id="01-为什么使用epoll"><a href="#01-为什么使用epoll" class="headerlink" title="01.为什么使用epoll"></a>01.为什么使用epoll</h1>]]></content>
    
    
    <categories>
      
      <category>C++八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月12日海康面试</title>
    <link href="/2025/03/12/20250312-1/"/>
    <url>/2025/03/12/20250312-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-模板（Templates）-vs-多态（Polymorphism）"><a href="#C-模板（Templates）-vs-多态（Polymorphism）" class="headerlink" title="C++ 模板（Templates） vs 多态（Polymorphism）"></a>C++ 模板（Templates） vs 多态（Polymorphism）</h1><h2 id="1-什么是-C-模板？"><a href="#1-什么是-C-模板？" class="headerlink" title="1. 什么是 C++ 模板？"></a>1. 什么是 C++ 模板？</h2><p>C++ <strong>模板（Templates）</strong> 是 <strong>编译时泛型编程（Generic Programming）</strong>，允许生成不同类型的代码。</p><h3 id="示例：函数模板"><a href="#示例：函数模板" class="headerlink" title="示例：函数模板"></a><strong>示例：函数模板</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;       <span class="hljs-comment">// 调用 int 版本</span><br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>) &lt;&lt; endl;   <span class="hljs-comment">// 调用 double 版本</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>编译时展开：编译器为 int 和 double 生成不同版本的 add()。</li><li>不使用 vtable，没有运行时动态分派。</li></ul><h1 id="C-std-map-的-Key-是否可以使用结构体？"><a href="#C-std-map-的-Key-是否可以使用结构体？" class="headerlink" title="C++ std::map 的 Key 是否可以使用结构体？"></a>C++ std::map 的 Key 是否可以使用结构体？</h1><p>✅ 是的，<code>std::map </code>的 <code>key </code>可以使用结构体，但需要满足以下条件：</p><ol><li>必须提供<code> &lt;（小于号运算符）</code>或 <code>std::less&lt;T&gt; </code>比较规则，因为 std::map 需要排序 key。</li><li>结构体必须是<code>可拷贝</code>和<code>可移动</code>的（默认 std::map 需要复制 key）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体作为 `std::map` 的 Key</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br><br>    <span class="hljs-comment">// 必须提供 `&lt;` 运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (x != other.x) <span class="hljs-keyword">return</span> x &lt; other.x;<br>        <span class="hljs-keyword">return</span> y &lt; other.y;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;Point, string&gt; pointMap;<br><br>    <span class="hljs-comment">// 插入数据</span><br>    pointMap[&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;] = <span class="hljs-string">&quot;A&quot;</span>;<br>    pointMap[&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;] = <span class="hljs-string">&quot;B&quot;</span>;<br>    pointMap[&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;] = <span class="hljs-string">&quot;C&quot;</span>;<br><br>    <span class="hljs-comment">// 遍历输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : pointMap) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Point(&quot;</span> &lt;&lt; key.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; key.y &lt;&lt; <span class="hljs-string">&quot;) -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="STL的六大组件"><a href="#STL的六大组件" class="headerlink" title="STL的六大组件"></a>STL的六大组件</h1><p>C++ STL（Standard Template Library，标准模板库）的六大组件 是 STL 的核心组成部分，它们分别是：<br>✅ 容器（Containers）作用： 存储和管理数据，是 STL 的核心部分。<br>✅ 算法（Algorithms）作用： 提供排序、查找、修改、计算等常见算法。<br>✅ 迭代器（Iterators）作用：在容器和算法之间提供统一的访问接口，使 STL 算法能够适用于不同容器。<br>✅ 仿函数（Functors）作用： 类似函数的对象，可以在 std::sort() 等 STL 算法中自定义比较规则。<br>✅ 适配器（Adapters）作用： 修改 STL 组件的行为。<br>✅ 分配器（Allocators）作用： 负责管理内存的分配和释放，通常使用默认 allocator<T>，但可以自定义。</p>]]></content>
    
    
    <categories>
      
      <category>大厂面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能计算岗位-cuda基础知识</title>
    <link href="/2025/03/11/cuda-basic/"/>
    <url>/2025/03/11/cuda-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="CUDA的线程组织结构"><a href="#CUDA的线程组织结构" class="headerlink" title="CUDA的线程组织结构"></a>CUDA的线程组织结构</h3><p>CUDA 的线程执行模型基于 SIMT（Single Instruction, Multiple Thread） 结构，采用层级化的线程组织方式，主要包括 Grid（网格）、Block（线程块）、Thread（线程） 三个层级。</p><h4 id="1-线程层级结构"><a href="#1-线程层级结构" class="headerlink" title="1. 线程层级结构"></a>1. 线程层级结构</h4><p>在 CUDA 中，线程的组织结构如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">Grid</span>（网格）<br> ├── Block(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)  ├── Block(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  ├── Block(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) ...<br> │     ...<br> ├── Block(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)  ├── Block(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)  ├── Block(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) ...<br> │     ...<br><br></code></pre></td></tr></table></figure><p>CUDA 线程层次：</p><p><strong>Grid（网格）</strong>：</p><ul><li>由多个 Block（线程块） 组成</li><li>Block 数量可以是一维、二维或三维</li></ul><p><strong>Block（线程块）</strong>：</p><ul><li>由多个 Thread（线程） 组成</li><li>每个 Block 共享一块共享内存（Shared Memory）</li><li>线程之间可以使用 __syncthreads() 同步</li></ul><p><strong>Thread（线程）</strong>：</p><ul><li>每个线程有自己的 寄存器（Register）</li><li>线程执行相同的 Kernel 代码，但操作不同的数据</li></ul><hr><h4 id="2-CUDA-线程索引"><a href="#2-CUDA-线程索引" class="headerlink" title="2. CUDA 线程索引"></a>2. CUDA 线程索引</h4><h2 id="CUDA-提供了线程索引（Thread-Indexing）-来标识每个线程的位置。3D-线程索引："><a href="#CUDA-提供了线程索引（Thread-Indexing）-来标识每个线程的位置。3D-线程索引：" class="headerlink" title="CUDA 提供了线程索引（Thread Indexing） 来标识每个线程的位置。3D 线程索引："></a>CUDA 提供了线程索引（Thread Indexing） 来标识每个线程的位置。<br>3D 线程索引：<br><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml">int <span class="hljs-variable language_">x</span> = threadIdx.<span class="hljs-variable language_">x</span> + blockIdx.<span class="hljs-variable language_">x</span> * blockDim.<span class="hljs-variable language_">x</span>;<br>int <span class="hljs-variable language_">y</span> = threadIdx.<span class="hljs-variable language_">y</span> + blockIdx.<span class="hljs-variable language_">y</span> * blockDim.<span class="hljs-variable language_">y</span>;<br>int z = threadIdx.z + blockIdx.z * blockDim.z;<br></code></pre></td></tr></table></figure></h2><h4 id="3-线程块和线程调度"><a href="#3-线程块和线程调度" class="headerlink" title="3. 线程块和线程调度"></a>3. 线程块和线程调度</h4><p><strong>SM（流式多处理器）调度</strong></p><ul><li>一个 GPU 由多个 SM 组成</li><li>每个 SM 可同时执行多个 Block</li><li>Block 内的线程以 Warp（32 个线程）为单位执行</li></ul><hr><h4 id="4-优化策略"><a href="#4-优化策略" class="headerlink" title="4. 优化策略"></a>4. 优化策略</h4><ul><li>合理组织 Grid 和 Block，保证最大计算吞吐量</li><li>使用 Shared Memory，减少全局内存访问</li><li>优化 Memory Coalescing，提高带宽利用率</li><li>避免 Warp 线程分支，提升计算效率</li></ul><h3 id="CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用"><a href="#CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用" class="headerlink" title="CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用"></a>CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用</h3><p>CUDA 主要有以下几种存储类型：</p><h3 id="CUDA-stream的概念，为什么要使用多个stream？"><a href="#CUDA-stream的概念，为什么要使用多个stream？" class="headerlink" title="CUDA stream的概念，为什么要使用多个stream？"></a>CUDA stream的概念，为什么要使用多个stream？</h3><h4 id="CUDA-Stream-的概念"><a href="#CUDA-Stream-的概念" class="headerlink" title="CUDA Stream 的概念"></a>CUDA Stream 的概念</h4><h4 id="1-什么是-CUDA-Stream？"><a href="#1-什么是-CUDA-Stream？" class="headerlink" title="1. 什么是 CUDA Stream？"></a>1. 什么是 CUDA Stream？</h4><p>CUDA <strong>Stream（流）</strong> 是 <strong>一个有序的 GPU 任务执行队列</strong>，其中的任务按顺序执行。多个 Stream 之间可以<strong>并行执行</strong>，从而提高 GPU 的计算效率。</p><h4 id="2-CUDA-Stream-的关键特点"><a href="#2-CUDA-Stream-的关键特点" class="headerlink" title="2. CUDA Stream 的关键特点"></a>2. CUDA Stream 的关键特点</h4><ul><li><strong>FIFO 方式</strong>：Stream 内的任务 <strong>按顺序执行</strong></li><li><strong>多个 Stream 并行</strong>：不同的 Stream 任务可以同时执行</li><li><strong>异步执行</strong>：允许计算和数据传输并行，提高 GPU 利用率</li><li><strong>减少 CPU-GPU 同步开销</strong>：避免 <code>cudaDeviceSynchronize()</code> 造成的阻塞</li></ul><hr><h4 id="3-为什么要使用多个-Stream？"><a href="#3-为什么要使用多个-Stream？" class="headerlink" title="3. 为什么要使用多个 Stream？"></a>3. 为什么要使用多个 Stream？</h4><p><strong>问题：单个 Stream 计算和数据传输串行执行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cudaMemcpy</span>(d_data, h_data, size, cudaMemcpyHostToDevice);  <span class="hljs-comment">// 数据拷贝（同步）</span><br>kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_data);  <span class="hljs-comment">// 核函数计算（需等待数据拷贝完成）</span><br><span class="hljs-built_in">cudaMemcpy</span>(h_data, d_data, size, cudaMemcpyDeviceToHost);  <span class="hljs-comment">// 数据拷贝（计算完成后）</span><br>cudaStream_t stream1, stream2;<br><span class="hljs-built_in">cudaStreamCreate</span>(&amp;stream1);<br><span class="hljs-built_in">cudaStreamCreate</span>(&amp;stream2);<br><br><span class="hljs-comment">// Stream 1 进行数据拷贝 + 计算</span><br><span class="hljs-built_in">cudaMemcpyAsync</span>(d_data1, h_data1, size, cudaMemcpyHostToDevice, stream1);<br>kernel&lt;&lt;&lt;grid, block, <span class="hljs-number">0</span>, stream1&gt;&gt;&gt;(d_data1);<br><span class="hljs-built_in">cudaMemcpyAsync</span>(h_data1, d_data1, size, cudaMemcpyDeviceToHost, stream1);<br><br><span class="hljs-comment">// Stream 2 进行数据拷贝 + 计算</span><br><span class="hljs-built_in">cudaMemcpyAsync</span>(d_data2, h_data2, size, cudaMemcpyHostToDevice, stream2);<br>kernel&lt;&lt;&lt;grid, block, <span class="hljs-number">0</span>, stream2&gt;&gt;&gt;(d_data2);<br><span class="hljs-built_in">cudaMemcpyAsync</span>(h_data2, d_data2, size, cudaMemcpyDeviceToHost, stream2);<br><br><span class="hljs-comment">// 等待所有 Stream 完成</span><br><span class="hljs-built_in">cudaDeviceSynchronize</span>();<br></code></pre></td></tr></table></figure><h4 id="4-CUDA-Stream-典型应用场景"><a href="#4-CUDA-Stream-典型应用场景" class="headerlink" title="4. CUDA Stream 典型应用场景"></a>4. CUDA Stream 典型应用场景</h4><p>✅ 1. 计算与数据传输并行<br>使用多个 Stream 让数据传输和计算同时进行，减少等待时间。</p><p>✅ 2. 并行执行多个 Kernel<br>适用于批量数据处理，如深度学习、图像处理等。</p><p>✅ 3. 提高吞吐量<br>适用于需要连续处理大量数据的应用，如视频流处理、点云计算等。</p><hr><h3 id="GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势"><a href="#GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势" class="headerlink" title="GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势"></a>GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势</h3><h4 id="GPU-和-CPU-的适用场景及架构优势"><a href="#GPU-和-CPU-的适用场景及架构优势" class="headerlink" title="GPU 和 CPU 的适用场景及架构优势"></a>GPU 和 CPU 的适用场景及架构优势</h4><h4 id="1-GPU-和-CPU-适合执行的程序类型"><a href="#1-GPU-和-CPU-适合执行的程序类型" class="headerlink" title="1. GPU 和 CPU 适合执行的程序类型"></a>1. <strong>GPU 和 CPU 适合执行的程序类型</strong></h4><table><thead><tr><th><strong>处理器</strong></th><th><strong>适合执行的任务</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>CPU（中央处理器）</strong></td><td><strong>复杂逻辑、多任务并发、顺序计算、低延迟任务</strong></td><td>操作系统、数据库、AI 逻辑处理、复杂决策、Web 服务器</td></tr><tr><td><strong>GPU（图形处理器）</strong></td><td><strong>大规模并行计算、数据密集型任务、高吞吐量计算</strong></td><td>深度学习训练、3D 渲染、图像处理、物理仿真、科学计算</td></tr></tbody></table><hr><h4 id="2-CPU-和-GPU-的硬件架构对比"><a href="#2-CPU-和-GPU-的硬件架构对比" class="headerlink" title="2. CPU 和 GPU 的硬件架构对比"></a>2. <strong>CPU 和 GPU 的硬件架构对比</strong></h4><h4 id="✅-1️⃣-CPU（中央处理器）的架构特点"><a href="#✅-1️⃣-CPU（中央处理器）的架构特点" class="headerlink" title="✅ 1️⃣ CPU（中央处理器）的架构特点"></a><strong>✅ 1️⃣ CPU（中央处理器）的架构特点</strong></h4><p><strong>CPU 的架构设计主要围绕“低延迟”和“复杂指令处理”</strong>，它的架构特点如下：</p><ul><li><strong>少量高性能核心（Cores）</strong></li><li><strong>高主频（GHz 级别），单核性能强</strong></li><li><strong>复杂的缓存层次（L1、L2、L3）</strong>，降低访存延迟</li><li><strong>支持分支预测和乱序执行</strong>，适合复杂的逻辑控制</li><li><strong>强大的指令集（x86、ARM）</strong>，适用于多种任务</li></ul><p>📌 <strong>CPU 适合的任务</strong></p><ul><li><strong>顺序计算任务</strong>（如执行 if-else、递归）</li><li><strong>多任务并发</strong>（如运行多个进程、操作系统调度）</li><li><strong>低延迟计算</strong>（如数据库查询、HTTP 请求处理）</li><li><strong>逻辑控制密集型任务</strong>（如操作系统、编译器）</li></ul><p>🔹 <strong>示例：CPU 适合的任务</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 递归计算斐波那契数列（CPU 擅长处理）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="✅-2️⃣-GPU（图形处理器）的架构特点"><a href="#✅-2️⃣-GPU（图形处理器）的架构特点" class="headerlink" title="✅ 2️⃣ GPU（图形处理器）的架构特点"></a><strong>✅ 2️⃣ GPU（图形处理器）的架构特点</strong></h4><p>GPU 的架构设计主要围绕“高吞吐量”和“大规模并行计算”，它的架构特点如下：</p><ul><li>大量并行计算核心（上千个 CUDA 核心）</li><li>较低主频，但极强的并行计算能力</li><li>SIMT（单指令多线程）架构，适合大规模数据并行</li><li>高带宽显存（GDDR6&#x2F;HBM）适合流式数据处理</li><li>优化的矩阵计算单元（Tensor Cores），适合深度学习训练<br>📌 GPU 适合的任务</li></ul><p>并行计算任务（如矩阵运算、点云处理）<br>数据密集型任务（如图像处理、物理仿真）<br>AI 和深度学习（如神经网络训练和推理）<br>高吞吐量计算（如 3D 渲染、视频编解码）<br>🔹 示例：GPU 适合的任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CUDA 计算向量加法（GPU 并行计算）</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">vectorAdd</span><span class="hljs-params">(<span class="hljs-type">float</span> *A, <span class="hljs-type">float</span> *B, <span class="hljs-type">float</span> *C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-type">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;<br>    <span class="hljs-keyword">if</span> (tid &lt; N) &#123;<br>        C[tid] = A[tid] + B[tid];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="平时如何进行kernel的优化，会用到哪些工具？"><a href="#平时如何进行kernel的优化，会用到哪些工具？" class="headerlink" title="平时如何进行kernel的优化，会用到哪些工具？"></a>平时如何进行kernel的优化，会用到哪些工具？</h4><h5 id="CUDA-Kernel-优化方法与工具"><a href="#CUDA-Kernel-优化方法与工具" class="headerlink" title="CUDA Kernel 优化方法与工具"></a>CUDA Kernel 优化方法与工具</h5><h6 id="1-Kernel-优化的主要策略"><a href="#1-Kernel-优化的主要策略" class="headerlink" title="1. Kernel 优化的主要策略"></a>1. Kernel 优化的主要策略</h6><p>CUDA Kernel 的优化可以从 <strong>计算效率、内存访问效率</strong> 和 <strong>并行度</strong> 三个方面进行提升。</p><h6 id="1-1-计算效率优化"><a href="#1-1-计算效率优化" class="headerlink" title="1.1 计算效率优化"></a><strong>1.1 计算效率优化</strong></h6><p>✅ <strong>减少分支分歧（Branch Divergence）</strong></p><ul><li>避免 <code>if-else</code> 结构导致的 Warp 线程分歧</li><li>例如，将 <code>if</code> 语句改为<strong>掩码操作</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value = (condition) ? a : b;  <span class="hljs-comment">// 避免 Warp 内线程执行不同路径</span><br></code></pre></td></tr></table></figure>✅ 提高 Warp 利用率</li><li>每个 Warp（32 线程）应尽可能全部执行，避免计算资源浪费</li><li>选择合适的 Block&#x2F;Thread 组织方式，填满 GPU 计算单元，网格大小是数据集大小除以线程块大小的商。<br>✅ 使用寄存器优化计算</li><li>尽量减少本地内存（Local Memory）使用，避免全局内存访问</li><li>使用 nvcc –ptxas-options&#x3D;-v 检查寄存器使用情况<br>1.2 内存访问优化<br>✅ 优化 Memory Coalescing（内存合并访问）</li><li>全局内存访问应对齐，确保线程按顺序访问连续内存<br>✅ 利用 Shared Memory（共享内存）</li><li>共享内存比全局内存快 100 倍，适合线程块内数据交换</li><li>需要避免 Bank Conflict（存储体冲突） 使用padding进行异或操作<br>✅ 使用 Texture Memory（纹理内存）优化读取</li><li>适用于二维或三维数据访问</li><li>纹理内存支持缓存，提高读取速度<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*resDesc 和 texDesc 代表什么意思？</span><br><span class="hljs-comment">resDesc（资源描述符，Resource Descriptor）：</span><br><span class="hljs-comment">定义 纹理数据的来源（如 CUDA 设备内存）。</span><br><span class="hljs-comment">指定数据格式（如 cudaChannelFormatDesc）。</span><br><span class="hljs-comment">texDesc（纹理描述符，Texture Descriptor）：</span><br><span class="hljs-comment">定义 纹理的行为（如插值模式、地址模式）。</span><br><span class="hljs-comment">设定访问模式（如 cudaFilterModeLinear 支持双线性插值）。*/</span><br>cudaTextureObject_t texObj;<br>cudaResourceDesc resDesc;<br>cudaTextureDesc texDesc;<br>cudaArray_t d_array;<br><br><span class="hljs-comment">// 1. 设置资源描述符</span><br><span class="hljs-built_in">memset</span>(&amp;resDesc, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(resDesc));<br>resDesc.resType = cudaResourceTypeArray;<br>resDesc.res.array.array = d_array;  <span class="hljs-comment">// 绑定 CUDA 数组</span><br><br><span class="hljs-comment">// 2. 设置纹理描述符</span><br><span class="hljs-built_in">memset</span>(&amp;texDesc, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(texDesc));<br>texDesc.addressMode[<span class="hljs-number">0</span>] = cudaAddressModeWrap;  <span class="hljs-comment">// 地址模式</span><br>texDesc.addressMode[<span class="hljs-number">1</span>] = cudaAddressModeWrap;<br>texDesc.filterMode = cudaFilterModeLinear;  <span class="hljs-comment">// 线性插值模式</span><br>texDesc.readMode = cudaReadModeElementType;  <span class="hljs-comment">// 读取原始数据</span><br><span class="hljs-comment">// 3. 创建纹理对象</span><br><span class="hljs-built_in">cudaCreateTextureObject</span>(&amp;texObj, &amp;resDesc, &amp;texDesc, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>1.3 提高并行度<br>✅ 调整 Grid 和 Block 大小</li><li>选择合适的 Block 维度，提高 SM 利用率<br>例如，2D 任务可使用 dim3 gridDim, blockDim<br>✅ 优化 Kernel 计算负载</li><li>避免过多的 Kernel 启动开销</li><li>尽量在 Kernel 内部执行更多计算，减少 CPU-GPU 交互<br><a href="https://blog.csdn.net/LostUnravel/article/details/135721041">https://blog.csdn.net/LostUnravel/article/details/135721041</a><br>✅ 对于block_size<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">最好是不小于 SM 上最大同时执行的线程数(Maximum number of resident threads per SM)和最大同时执行的线程块数(Maximum number of resident blocks per SM)的比值.<br>因为要尽可能让 GPU 占有率(Occupancy, SM 上并发执行的线程数和 SM 上最大支持的线程数的比值)达到 <span class="hljs-number">100%</span><br>!<span class="hljs-selector-attr">[alt text]</span>(image.png)<br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">寄存器、共享内存等资源对应到每个线程不能超过上限(每个 <span class="hljs-built_in">block</span> 的 <span class="hljs-number">32</span> 位寄存器数量, 每个 <span class="hljs-built_in">block</span> 的共享内存大小上限). 这里指明为<span class="hljs-string">&quot;对应到每个线程&quot;</span>, 即每个线程所使用的寄存器数、共享内存应小于上限/ block_size.<br></code></pre></td></tr></table></figure>✅ 对于grid_size（总的线程数量）</li><li>其应 SM 数量 * 每个 SM 最大 block 数个 block<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stan">因为每个 <span class="hljs-built_in">block</span> 的计算量相等，所以所有 SM 应几乎同时完成这些 <span class="hljs-built_in">block</span> 的计算，然后处理下一批，这其中的每一批被称之为一个 wave。想象如果 grid_size 恰好比一个 wave 多出一个 <span class="hljs-built_in">block</span>，因为 stream 上的下个 kernel 要等这个 kernel 完全执行完成后才能开始执行，所以第一个 wave 完成后，GPU 上将只有一个 <span class="hljs-built_in">block</span> 在执行，GPU 的实际利用率会很低，这种情况被称之为 <span class="hljs-built_in">tail</span> effect，我们应尽量避免这种情况。将 grid_size 设置为精确的一个 wave 可能也无法避免 <span class="hljs-built_in">tail</span> effect，因为 GPU 可能不是被当前 stream 独占的，常见的如 NCCL 执行时会占用一些 SM。<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="cuda矩阵乘法"><a href="#cuda矩阵乘法" class="headerlink" title="cuda矩阵乘法"></a>cuda矩阵乘法</h3><h4 id="1-原始版本"><a href="#1-原始版本" class="headerlink" title="1.原始版本"></a>1.原始版本</h4><ul><li>直接使用全局内存进行矩阵乘法的运算<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE 16  <span class="hljs-comment">// 线程块大小，控制并行度</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// **CUDA 核函数**：执行矩阵乘法 C = A * B</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">matrixMulKernel</span><span class="hljs-params">(<span class="hljs-type">float</span> *A, <span class="hljs-type">float</span> *B, <span class="hljs-type">float</span> *C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-comment">// 计算当前线程在网格中的全局索引</span><br>    <span class="hljs-type">int</span> row = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-type">int</span> col = blockIdx.x * blockDim.x + threadIdx.x;<br><br>    <span class="hljs-type">float</span> sum = <span class="hljs-number">0.0f</span>;<br>    <br>    <span class="hljs-comment">// **确保线程索引在矩阵范围内**</span><br>    <span class="hljs-keyword">if</span> (row &lt; N &amp;&amp; col &lt; N) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; N; ++k) &#123;<br>            sum += A[row * N + k] * B[k * N + col];<br>        &#125;<br>        C[row * N + col] = sum;  <span class="hljs-comment">// 赋值到结果矩阵</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// **主机端代码**（CPU 端）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matrixMultiplication</span><span class="hljs-params">(<span class="hljs-type">float</span> *h_A, <span class="hljs-type">float</span> *h_B, <span class="hljs-type">float</span> *h_C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = N * N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>    <span class="hljs-type">float</span> *d_A, *d_B, *d_C;<br><br>    <span class="hljs-comment">// **分配 GPU 内存**</span><br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_A, size);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_B, size);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_C, size);<br><br>    <span class="hljs-comment">// **复制数据到 GPU**</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_A, h_A, size, cudaMemcpyHostToDevice);<br>    <span class="hljs-built_in">cudaMemcpy</span>(d_B, h_B, size, cudaMemcpyHostToDevice);<br><br>    <span class="hljs-comment">// **设置 CUDA 线程块和网格**</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">threadsPerBlock</span><span class="hljs-params">(BLOCK_SIZE, BLOCK_SIZE)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">blocksPerGrid</span><span class="hljs-params">((N + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE, (N + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE)</span></span>;<br><br>    <span class="hljs-comment">// **调用 CUDA 核函数**</span><br>    matrixMulKernel&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(d_A, d_B, d_C, N);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();  <span class="hljs-comment">// **确保计算完成**</span><br><br>    <span class="hljs-comment">// **将结果复制回主机**</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(h_C, d_C, size, cudaMemcpyDeviceToHost);<br><br>    <span class="hljs-comment">// **释放 GPU 内存**</span><br>    <span class="hljs-built_in">cudaFree</span>(d_A);<br>    <span class="hljs-built_in">cudaFree</span>(d_B);<br>    <span class="hljs-built_in">cudaFree</span>(d_C);<br>&#125;<br><br><span class="hljs-comment">// **打印矩阵**</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-type">float</span> *matrix, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j) &#123;<br>            cout &lt;&lt; matrix[i * N + j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// **主函数**</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 矩阵大小</span><br>    <span class="hljs-type">int</span> size = N * N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br><br>    <span class="hljs-comment">// **分配主机端矩阵**</span><br>    <span class="hljs-type">float</span> *h_A = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[N * N];<br>    <span class="hljs-type">float</span> *h_B = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[N * N];<br>    <span class="hljs-type">float</span> *h_C = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[N * N];<br><br>    <span class="hljs-comment">// **初始化矩阵**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N * N; i++) &#123;<br>        h_A[i] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>);<br>        h_B[i] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Matrix A:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printMatrix</span>(h_A, N);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Matrix B:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printMatrix</span>(h_B, N);<br><br>    <span class="hljs-comment">// **执行 CUDA 矩阵乘法**</span><br>    <span class="hljs-built_in">matrixMultiplication</span>(h_A, h_B, h_C, N);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Result Matrix C = A * B:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printMatrix</span>(h_C, N);<br><br>    <span class="hljs-comment">// **释放主机内存**</span><br>    <span class="hljs-keyword">delete</span>[] h_A;<br>    <span class="hljs-keyword">delete</span>[] h_B;<br>    <span class="hljs-keyword">delete</span>[] h_C;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-增加共享内存"><a href="#2-增加共享内存" class="headerlink" title="2.增加共享内存"></a>2.增加共享内存</h4><ul><li>采用共享内存进行矩阵乘法的运算<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// **共享内存的 CUDA 核函数**</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">matrixMulShared</span><span class="hljs-params">(<span class="hljs-type">float</span> *A, <span class="hljs-type">float</span> *B, <span class="hljs-type">float</span> *C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-comment">// **共享内存**</span><br>    __shared__ <span class="hljs-type">float</span> Asub[BLOCK_SIZE][BLOCK_SIZE];<br>    __shared__ <span class="hljs-type">float</span> Bsub[BLOCK_SIZE][BLOCK_SIZE];<br><br>    <span class="hljs-comment">// 计算当前线程的全局索引</span><br>    <span class="hljs-type">int</span> row = blockIdx.y * BLOCK_SIZE + threadIdx.y;<br>    <span class="hljs-type">int</span> col = blockIdx.x * BLOCK_SIZE + threadIdx.x;<br><br>    <span class="hljs-type">float</span> sum = <span class="hljs-number">0.0f</span>;<br><br>    <span class="hljs-comment">// **以 BLOCK_SIZE 为单位，遍历 A 和 B 的子矩阵**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (N + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE; ++i) &#123;<br>        <span class="hljs-comment">// **加载 A 和 B 的子块到共享内存**</span><br>        <span class="hljs-keyword">if</span> (row &lt; N &amp;&amp; (i * BLOCK_SIZE + threadIdx.x) &lt; N)<br>            Asub[threadIdx.y][threadIdx.x] = A[row * N + i * BLOCK_SIZE + threadIdx.x];<br>        <span class="hljs-keyword">else</span><br>            Asub[threadIdx.y][threadIdx.x] = <span class="hljs-number">0.0f</span>;<br><br>        <span class="hljs-keyword">if</span> (col &lt; N &amp;&amp; (i * BLOCK_SIZE + threadIdx.y) &lt; N)<br>            Bsub[threadIdx.y][threadIdx.x] = B[(i * BLOCK_SIZE + threadIdx.y) * N + col];<br>        <span class="hljs-keyword">else</span><br>            Bsub[threadIdx.y][threadIdx.x] = <span class="hljs-number">0.0f</span>;<br><br>        __syncthreads();  <span class="hljs-comment">// **同步线程，确保所有线程都加载完成**</span><br><br>        <span class="hljs-comment">// **计算当前 C[row, col]**</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; BLOCK_SIZE; ++k)<br>            sum += Asub[threadIdx.y][k] * Bsub[k][threadIdx.x];<br><br>        __syncthreads();  <span class="hljs-comment">// **确保计算完成后再加载新的数据**</span><br>    &#125;<br><br>    <span class="hljs-comment">// **存储计算结果**</span><br>    <span class="hljs-keyword">if</span> (row &lt; N &amp;&amp; col &lt; N)<br>        C[row * N + col] = sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-增加共享内存"><a href="#3-增加共享内存" class="headerlink" title="3.增加共享内存"></a>3.增加共享内存</h4><p>共享内存 reduce-sum 基础版本<br>未优化的 Kernel</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduceSumNaive</span><span class="hljs-params">(<span class="hljs-type">float</span> *d_in, <span class="hljs-type">float</span> *d_out, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    __shared__ <span class="hljs-type">float</span> sharedMem[<span class="hljs-number">1024</span>];  <span class="hljs-comment">// 共享内存</span><br>    <span class="hljs-type">int</span> tid = threadIdx.x;<br>    <span class="hljs-type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;<br><br>    <span class="hljs-comment">// **加载数据到共享内存**</span><br>    <span class="hljs-keyword">if</span> (idx &lt; n)<br>        sharedMem[tid] = d_in[idx];<br>    <span class="hljs-keyword">else</span><br>        sharedMem[tid] = <span class="hljs-number">0.0f</span>;  <span class="hljs-comment">// 处理越界情况</span><br><br>    __syncthreads();  <span class="hljs-comment">// 确保所有线程都加载完成</span><br><br>    <span class="hljs-comment">// **归约求和（标准 Reduction）**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = blockDim.x / <span class="hljs-number">2</span>; s &gt; <span class="hljs-number">0</span>; s &gt;&gt;= <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// s 依次减少为 512, 256, 128, ...</span><br>        <span class="hljs-keyword">if</span> (tid &lt; s) &#123;<br>            sharedMem[tid] += sharedMem[tid + s];  <span class="hljs-comment">// 线程对数据累加</span><br>        &#125;<br>        __syncthreads();  <span class="hljs-comment">// 确保所有线程完成</span><br>    &#125;<br><br>    <span class="hljs-comment">// **将结果存回全局内存**</span><br>    <span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>) <br>        d_out[blockIdx.x] = sharedMem[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>解决 Bank Conflict：交错存储（Strided Access）</p><ul><li>调整访问模式，让不同线程访问不同的 Bank，避免 Bank Conflict。</li><li>使用对数归约（Optimized Reduction），减少线程同步次数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduceSumOptimized</span><span class="hljs-params">(<span class="hljs-type">float</span> *d_in, <span class="hljs-type">float</span> *d_out, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    __shared__ <span class="hljs-type">float</span> sharedMem[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-type">int</span> tid = threadIdx.x;<br>    <span class="hljs-type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;<br><br>    <span class="hljs-comment">// **交错存储，减少 Bank Conflict**</span><br>    <span class="hljs-keyword">if</span> (idx &lt; n)<br>        sharedMem[tid] = d_in[idx];<br>    <span class="hljs-keyword">else</span><br>        sharedMem[tid] = <span class="hljs-number">0.0f</span>;  <span class="hljs-comment">// 处理越界情况</span><br><br>    __syncthreads();<br><br>    <span class="hljs-comment">// **优化的 Reduction**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = blockDim.x / <span class="hljs-number">2</span>; s &gt; <span class="hljs-number">0</span>; s &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tid &lt; s) &#123;<br>            sharedMem[tid] += sharedMem[tid + s];<br>        &#125;<br>        __syncthreads();<br>    &#125;<br><br>    <span class="hljs-comment">// **存回全局内存**</span><br>    <span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br>        d_out[blockIdx.x] = sharedMem[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="解决bank冲突的常见方法"><a href="#解决bank冲突的常见方法" class="headerlink" title="解决bank冲突的常见方法"></a>解决bank冲突的常见方法</h4><ul><li>Swizzle 中采用将索引与行进行异或从而消除了存储体冲突并对齐了地址 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">half* <span class="hljs-title">row_swizzled_layout</span><span class="hljs-params">(half* data, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> address = (<span class="hljs-type">uint64_t</span>)&amp;data[r * columns + c];    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;half *&gt;(address ^ (r &lt;&lt; <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li><li>padding是Bank Conflict的常见解决方案的一种用一个存储体“填充”每一行，从而引入偏移量以将列的连续元素移动到不同的存储体中。这消除了存储体冲突，但会产生未对齐的地址，从而干扰需要对齐地址的快速指令。</li></ul>]]></content>
    
    
    <categories>
      
      <category>cuda八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能计算岗位-cuda矩阵转置</title>
    <link href="/2025/03/10/20250310/"/>
    <url>/2025/03/10/20250310/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个矩阵 <code>src</code>，输出其转置后的矩阵 <code>out</code>。<br><strong>示例</strong>:<br>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在矩阵转置中，原矩阵中位于第 <code>i</code> 行第 <code>j</code> 列的元素，对应到转置后的矩阵中就是第 <code>j</code> 行第 <code>i</code> 列的位置。因此，通过简单地将索引对调即可完成矩阵转置。</p><p>CUDA 的实现则需要将每个线程映射到矩阵中的一个元素。具体步骤如下：</p><ol><li>每个线程获取自身的全局索引。</li><li>检查索引是否越界（确保线程对应的索引在矩阵范围内）。</li><li>根据索引计算出原矩阵元素的位置，将其写入到转置矩阵的正确位置。</li></ol><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下代码演示了一个简单的 CUDA 实现，展示了如何使用 CUDA 核函数将矩阵转置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;device_launch_parameters.h&gt;</span></span><br><br><span class="hljs-comment">// CUDA 核函数：实现矩阵转置</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">transposeKernel</span><span class="hljs-params">(<span class="hljs-type">int</span> *src, <span class="hljs-type">int</span>* out, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> tid_x = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-type">int</span> tid_y = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-keyword">if</span> (tid_x &lt; width &amp;&amp; tid_y &lt; height) &#123;<br>        <span class="hljs-type">int</span> input = tid_y * width + tid_x;<br>        <span class="hljs-type">int</span> output = tid_x * height + tid_y;<br>        out[output] = src[input];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> height = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> size = width * height * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><br>    <span class="hljs-comment">// 分配主机内存</span><br>    <span class="hljs-type">int</span> *src = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[width * height];<br>    <span class="hljs-type">int</span> *out = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[width * height];<br><br>    <span class="hljs-comment">// 分配设备内存</span><br>    <span class="hljs-type">int</span> *d_src, *d_out;<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span>**)&amp;d_src, size);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span>**)&amp;d_out, size);<br><br>    <span class="hljs-comment">// 初始化输入矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width * height; i++) &#123;<br>        src[i] = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 将数据从主机拷贝到设备</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_src, src, size, cudaMemcpyHostToDevice);<br><br>    <span class="hljs-comment">// 配置线程块和线程网格</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((width + block.x - <span class="hljs-number">1</span>) / block.x, (height + block.y - <span class="hljs-number">1</span>) / block.y)</span></span>;<br><br>    <span class="hljs-comment">// 启动CUDA核函数</span><br>    transposeKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_src, d_out, width, height);<br><br>    <span class="hljs-comment">// 将结果从设备拷贝回主机</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(out, d_out, size, cudaMemcpyDeviceToHost);<br><br>    <span class="hljs-comment">// 打印部分结果进行验证</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        std::cout &lt;&lt; out[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">delete</span>[] src;<br>    <span class="hljs-keyword">delete</span>[] out;<br>    <span class="hljs-built_in">cudaFree</span>(d_src);<br>    <span class="hljs-built_in">cudaFree</span>(d_out);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试手撕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月9日金山上机笔试题目</title>
    <link href="/2025/03/09/jd20250309/"/>
    <url>/2025/03/09/jd20250309/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含字母和数字的字符串 <code>str</code>，需要输出其中最长的连续数字子串。<br><strong>输入描述</strong>: 一个由字母和数字组成的字符串，长度不超过255；字符串保证至少有一个数字字符，并且只有一个最长的数字子串。<br><strong>输出描述</strong>: 最长的数字子串。<br><strong>示例</strong>:<br>输入：abcd12345ed125ss123058789<br>输出：123058789</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>利用 <code>isdigit()</code> 函数判断字符是否为数字。  </li><li>使用滑动窗口技巧，记录数字子串的起始位置及其长度。  </li><li>在遍历结束后，比较当前记录的数字子串长度和之前的最长长度，更新最长的子串。</li></ol><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是 C++ 的实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 获取最长数字子串</span><br><span class="hljs-function">string <span class="hljs-title">getMaxNumberToArray</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; src)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = src.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 最长数字子串的长度</span><br>    <span class="hljs-type">int</span> currentLength = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 当前数字子串的长度</span><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 当前数字子串的起始位置</span><br>    <span class="hljs-type">int</span> maxStart = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最长数字子串的起始位置</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">char</span> c = src[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (currentLength == <span class="hljs-number">0</span>)<br>            &#123;<br>                start = i;<br>            &#125;<br>            currentLength++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (currentLength &gt; maxLength)<br>            &#123;<br>                maxLength = currentLength;<br>                maxStart = start;<br>            &#125;<br>            currentLength = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后再检查一次当前数字子串是否是最长</span><br>    <span class="hljs-keyword">if</span> (currentLength &gt; maxLength)<br>    &#123;<br>        maxLength = currentLength;<br>        maxStart = start;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> src.<span class="hljs-built_in">substr</span>(maxStart, maxLength);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string line;<br>    <span class="hljs-built_in">getline</span>(cin,line);<br>    cout &lt;&lt; <span class="hljs-built_in">getMaxNumberToArray</span>(line) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大厂笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板</title>
    <link href="/2025/03/08/My-First-Note/"/>
    <url>/2025/03/08/My-First-Note/</url>
    
    <content type="html"><![CDATA[<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n; <span class="hljs-comment">// 我们定义target在左闭右开的区间里，[left, right)  </span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle; <span class="hljs-comment">// target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在 [middle+1, right)中</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值的情况，直接返回下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="深度优先遍历（递归）"><a href="#深度优先遍历（递归）" class="headerlink" title="深度优先遍历（递归）"></a>深度优先遍历（递归）</h4><p>前序遍历（中左右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中 ，同时也是处理节点逻辑的地方</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历（左中右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中 ，同时也是处理节点逻辑的地方</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历（左右中）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中 ，同时也是处理节点逻辑的地方</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深度优先遍历（迭代法）"><a href="#深度优先遍历（迭代法）" class="headerlink" title="深度优先遍历（迭代法）"></a>深度优先遍历（迭代法）</h4><p>相关题解：<a href="https://github.com/youngyangyang04/leetcode/blob/master/problems/0094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.md">0094.二叉树的中序遍历</a></p><p>前序遍历（中左右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>            st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);                          <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);            <span class="hljs-comment">// 节点处理逻辑</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>中序遍历（左中右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 存放中序遍历的元素</span><br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>(); <br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>(); <br>            node = st.<span class="hljs-built_in">top</span>(); <br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);            <span class="hljs-comment">// 节点处理逻辑</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历（左右中）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);            <span class="hljs-comment">// 节点处理逻辑</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="广度优先遍历（队列）"><a href="#广度优先遍历（队列）" class="headerlink" title="广度优先遍历（队列）"></a>广度优先遍历（队列）</h4><p>相关题解：<a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">0102.二叉树的层序遍历</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    queue&lt;TreeNode*&gt; que;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()</span><br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);   <span class="hljs-comment">// 节点处理的逻辑</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(vec);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以直接解决如下题目：</p><ul><li><p><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">0102.二叉树的层序遍历</a></p></li><li><p><a href="https://github.com/youngyangyang04/leetcode/blob/master/problems/0199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE.md">0199.二叉树的右视图</a></p></li><li><p><a href="https://github.com/youngyangyang04/leetcode/blob/master/problems/0637.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC.md">0637.二叉树的层平均值</a> </p></li><li><p><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">0104.二叉树的最大深度 （迭代法）</a></p></li><li><p><a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html">0111.二叉树的最小深度（迭代法）</a></p></li><li><p><a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html">0222.完全二叉树的节点个数（迭代法）</a></p></li></ul><h4 id="二叉树深度"><a href="#二叉树深度" class="headerlink" title="二叉树深度"></a>二叉树深度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(node-&gt;left), <span class="hljs-built_in">getDepth</span>(node-&gt;right));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树节点数量"><a href="#二叉树节点数量" class="headerlink" title="二叉树节点数量"></a>二叉树节点数量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// 根据题意而定 </span><br><span class="hljs-type">int</span> father[<span class="hljs-number">1005</span>];<br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ;<br>    father[v] = u;<br>&#125;<br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大厂笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
