<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>20250323-hot100</title>
    <link href="/2025/03/23/20250323-hot100/"/>
    <url>/2025/03/23/20250323-hot100/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月20日hot100练习</title>
    <link href="/2025/03/20/20250320-hot100/"/>
    <url>/2025/03/20/20250320-hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a>25.K个一组翻转链表</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>1.判断剩下的节点是否够k个<br>2.将k个链点逆序<br>3.翻转下一组链表节点</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//判断剩下的节点是否够k个</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* temp = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!temp) <span class="hljs-keyword">return</span> head;<br>            temp = temp-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//再将k个链点逆序</span><br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        ListNode* nex = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++)<br>        &#123;<br>            nex = cur-&gt;next;<br><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nex;<br>        &#125;<br>        <span class="hljs-comment">//翻转下一组链表节点</span><br>        head-&gt;next = <span class="hljs-built_in">reverseKGroup</span>(cur,k);<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.排序链表</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><h2 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h2><p><img src="/2025/03/20/20250320-hot100/image.png" alt="alt text"></p><h2 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//如果链表为空或者只有一个节点，无需排序</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* head2 = <span class="hljs-built_in">middleNode</span>(head);<br>        head = <span class="hljs-built_in">sortList</span>(head);<br>        head2 = <span class="hljs-built_in">sortList</span>(head2);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoList</span>(head,head2);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre = head;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)<br>        &#123;<br>            pre = slow;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//断开slow的前一个结点和slow的连接</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoList</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!l1) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(!l2) <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) <br>        &#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwoList</span>(l1-&gt;next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            l2-&gt;next = <span class="hljs-built_in">mergeTwoList</span>(l1,l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode-hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月19日hot100练习</title>
    <link href="/2025/03/19/20250318-hot100/"/>
    <url>/2025/03/19/20250318-hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><h2 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h2><p>对于回文串来说其主要做法是逆转中点之后的子串，然后进行分隔，再逐一比对是否有不相同的字符，因此整个过程分为以下几个步骤：<br>a.通过slow与fast指针找到链表的中点位置mid；<br>b.然后将区间[mid,end]之间的子链表进行反转<br>c.将[start,mid)间的链表与再逐一对比</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        ListNode* nex = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur)<br>        &#123;<br>            nex = cur-&gt;next;<br>            <br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow  = head;<br>        <span class="hljs-comment">//这里需要注意边界问题</span><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)<br>        &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        ListNode* nodeR = <span class="hljs-built_in">reverse</span>(slow);<br>        ListNode* nodeL = head;<br> <br>        <span class="hljs-keyword">while</span>(nodeR)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nodeR-&gt;val!=nodeL-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            nodeL = nodeL-&gt;next;<br>            nodeR = nodeR-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>通过设置一个slow指针与一个fast指针，当slow与fast相遇时，代表链表有环，如果fast在过程中等于nullptr的话，代表其链表无环。</p><h2 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h2><ul><li>这是我一开始写的版本：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>            <span class="hljs-keyword">if</span>(!slow-&gt;next || !fast-&gt;next || !fast-&gt;next-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>然后将这段代码给gpt润色，她给我提了如下建议：</li></ul><ol><li>fast 指针初始化时不需要直接指向 head-&gt;next<br>代码中将 fast 初始化为 head-&gt;next，但没有必要这么做。根据快慢指针的常见实现，fast 和 slow 都应该从 head 开始。fast 指针在循环过程中会每次走两步，slow 指针走一步。将 fast 和 slow 都初始化为 head 是更直观且一致的做法。</li><li>减少不必要的空指针检查<br>在 while 循环中，进行了多次的空指针检查，特别是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(!slow-&gt;next || !fast-&gt;next || !fast-&gt;next-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>因为如果 fast 或 fast-&gt;next 为 nullptr，说明链表已经到达末尾，没有环。slow-&gt;next 的检查是多余的，因为我们在每次循环之前已经通过 fast 的检查来确保 fast 和 fast-&gt;next 不为空。这些检查实际上可以更简洁地写成：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li>避免重复的 slow 和 fast 的访问<br>代码每次都访问了 slow-&gt;next 和 fast-&gt;next-&gt;next。这是不必要的，因为只需要在循环的开头就检查一次 fast 和 fast-&gt;next 是否为空，然后才移动指针。</li><li>对头节点的空指针检查放在最前面<br>头节点为空或者只有一个节点时，直接返回 false，无需继续执行其他逻辑，已经很高效。<br>优化后的代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 空链表或单节点链表没有环</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;  <span class="hljs-comment">// 只检查 fast 和 fast-&gt;next 是否为空</span><br>            slow = slow-&gt;next;  <span class="hljs-comment">// 慢指针每次走一步</span><br>            fast = fast-&gt;next-&gt;next;  <span class="hljs-comment">// 快指针每次走两步</span><br>            <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 快慢指针相遇，说明有环</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 快指针走到链表末尾，无环</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许<code>修改链表</code>。</p><h2 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h2><p>假设：fast每次走两步，slow每次走一步,a为起点到环口的距离，b为环口到相遇点的距离，c为相遇点顺时针到环口的距离<br>(1) fastStep &#x3D; 2<em>slowStep &#x3D; a+n</em>(b+c)<br>(2) slowStep &#x3D; a+b<br>由(1)、(2)可得a &#x3D; (n-1)(b+c) + c<br>因此我们可以从相遇点和起点开始重新走，直到fast和slow指针再次相遇</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)<br>        &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        fast = head;<br>        <span class="hljs-keyword">while</span>(fast!=slow)<br>        &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>将两个<code>升序</code>链表合并为一个新的<code>升序</code>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h2 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h2><p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><h2 id="代码编写：-2"><a href="#代码编写：-2" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果其中一个链表为空，直接返回另一个链表</span><br>        <span class="hljs-keyword">if</span> (!list1) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (!list2) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)<br>        &#123;<br>            list1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next,list2); <br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            list2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1,list2-&gt;next); <br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h1><h2 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><h2 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h2><p>设定快慢指针，快指针先走n步，然后慢指针从头开始走，直到快指针探测到nullptr</p><h2 id="代码编写：-3"><a href="#代码编写：-3" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <br>        <span class="hljs-comment">// 创建一个虚拟头节点，方便处理删除头节点的情况</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* slow = dummy;<br>        ListNode* fast = dummy;<br>        <br>        <span class="hljs-comment">// 快指针先走 n+1 步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 快慢指针一起移动，直到快指针到达末尾</span><br>        <span class="hljs-keyword">while</span> (fast) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 删除慢指针后面的节点</span><br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <br>        <span class="hljs-comment">// 返回新的头节点</span><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h1><h2 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><h2 id="思路分析：-2"><a href="#思路分析：-2" class="headerlink" title="思路分析："></a>思路分析：</h2><blockquote><p> ListNode* l1 &#x3D; head;<br> ListNode* l2 &#x3D; head-&gt;next;<br> ListNode* l3 &#x3D; l2-&gt;next;<br>然后将l3作为分支的头按相同的逻辑进行节点的重新关联</p></blockquote><h2 id="代码编写：-4"><a href="#代码编写：-4" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* l1 = head;<br>        ListNode* l2 = head-&gt;next;<br>        ListNode* l3 = l2-&gt;next;<br>        l1-&gt;next = <span class="hljs-built_in">swapPairs</span>(l3);<br>        l2-&gt;next = l1;<br>        <span class="hljs-keyword">return</span>  l2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode-hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月17日hot100练习</title>
    <link href="/2025/03/17/20250317-hot100/"/>
    <url>/2025/03/17/20250317-hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h2><p>a.第一轮从起始位置开始遍历数组，比较相邻两个值的大小，如果a&gt;b，则交换他们两个的位置<br>b.放置好第一个最大的位置后，然后循环a步骤，直至排序完毕</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++) &#123;<br>        <span class="hljs-comment">// 标志位，用于检测是否发生了交换</span><br>        <span class="hljs-type">bool</span> swapped = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 内层循环，每次遍历将最大的元素“冒泡”到末尾</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j<span class="hljs-number">+1</span>]) &#123;<br>                <span class="hljs-comment">// 交换相邻的两个元素</span><br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j<span class="hljs-number">+1</span>]);<br>                swapped = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果没有发生交换，说明数组已经有序，提前退出</span><br>        <span class="hljs-keyword">if</span> (!swapped) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h1><h2 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h2><p>a.选取当前数组中一个元素作为基准值base<br>b.将数组中的元素与base进行比较，将小于base的放置在左边，大于base的放置在右边<br>c.此时数组被分成两个部分part1和part2，然后每个子部分单独进行递归，重复1-3步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 快速排序的分区函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[high];  <span class="hljs-comment">// 选定最后一个元素为基准</span><br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;  <span class="hljs-comment">// i 用来追踪小于基准的元素位置</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt; high; j++) &#123;<br>        <span class="hljs-comment">// 如果当前元素小于或等于基准，则交换</span><br>        <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>            i++;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将基准放到正确的位置</span><br>    <span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 快速排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-comment">// 获取分区位置</span><br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, low, high);<br><br>        <span class="hljs-comment">// 递归排序分区的两部分</span><br>        <span class="hljs-built_in">quickSort</span>(arr, low, pi - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pi + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。图示两个链表在节点 c1 开始相交：<br>题目数据 保证整个链式结构中不存在环。注意，函数返回结果后，链表必须保持其原始结构 。</p></blockquote><h2 id="思路分析：-2"><a href="#思路分析：-2" class="headerlink" title="思路分析："></a>思路分析：</h2><p>由于链表a和b其对应的长度不一定等长，因此需要关注<code>等长</code>这个关键词，可以联想到a+b&#x3D;b+a的长度，那么就存在一个位置<code>c</code>，从此刻开始走的链表其会同时到达相交点；<br>a.对于链表a来说，首先从头节点出发，如果遇到nullptr节点时，则转移到b节点的头位置<br>b.对于链表b来说，首先从头节点出发，如果遇到nullptr节点时，则转移到a节点的头位置</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-keyword">while</span>(curA!=curB )<br>        &#123;<br>            curA = curA?curA-&gt;next:headB;<br>            curB = curB?curB-&gt;next:headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode-hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20250315好未来笔试</title>
    <link href="/2025/03/15/20250315%E5%A5%BD%E6%9C%AA%E6%9D%A5%E7%AC%94%E8%AF%95/"/>
    <url>/2025/03/15/20250315%E5%A5%BD%E6%9C%AA%E6%9D%A5%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134.加油站"></a>134.加油站</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。<br>示例 1:</p><blockquote><p>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br>输出: 3<br>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。<br>示例 2:<br>输入: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]<br>输出: -1<br>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p></blockquote><h2 id="思路解析："><a href="#思路解析：" class="headerlink" title="思路解析："></a>思路解析：</h2><p>假设我们此前发现，从加油站 x 出发，每经过一个加油站就加一次油（包括起始加油站），最后一个可以到达的加油站是 y（不妨设 x&lt;y）。这就说明：<br>第一个式子表明无法到达加油站 y 的下一个加油站，第二个式子表明可以到达 y 以及 y 之前的所有加油站。<br>现在，考虑任意一个位于 x,y 之间的加油站 z（包括 x 和 y），我们现在考察从该加油站出发，能否到达加油站 y 的下一个加油站，也就是要判断区间[z,y]内的加油总和与[z,y]内的<br>支出总和的关系。根据以上式子可得：<br>从上面的推导中，能够得出结论：从 x,y 之间的任何一个加油站出发，都无法到达加油站 y 的下一个加油站。我们首先检查第 0 个加油站，并试图判断能否环绕一周；如果不能，就从第一个无法到达的加油站开始继续检查。</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cursum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            cursum += gas[i] - cost[i];<br>            sum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span>(cursum &lt; <span class="hljs-number">0</span>) &#123;<br>                start = i<span class="hljs-number">+1</span>;<br>                cursum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a>665. 非递减数列</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;&#x3D; i &lt;&#x3D; n-2)，总满足 nums[i] &lt;&#x3D; nums[i + 1]。<br>示例 1:</p><blockquote><p>输入: nums &#x3D; [4,2,3]<br>输出: true<br>解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。<br>示例 2:<br>输入: nums &#x3D; [4,2,1]<br>输出: false<br>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</p></blockquote><h2 id="思路解析：-1"><a href="#思路解析：-1" class="headerlink" title="思路解析："></a>思路解析：</h2><p>寻找一个下降的相邻数组，num[i-1]&gt;num[i],索引位置记作i-1,i；由于不知道i之后的数组是大还是小，因此尽量不调整i<br>a.将i-1变小，满足num[i-2]&lt; num[i-1] &lt;&#x3D; num[i]<br>b.将i变大，满足num[i-2]&lt; num[i-1] &lt;&#x3D; num[i]</p><h2 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&gt;nums[i])<br>            &#123;<br>                <span class="hljs-comment">//1.调整i-1的值，将其调整到大于i-2小于i的范围内</span><br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> || nums[i]&gt;=nums[i<span class="hljs-number">-2</span>])<br>                &#123;<br>                    nums[i<span class="hljs-number">-1</span>] = nums[i];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                <span class="hljs-comment">//调整i的值，将其向上调整</span><br>                    nums[i] = nums[i<span class="hljs-number">-1</span>];<br>                &#125;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (cnt&lt;=<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><blockquote><p>输入：matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4</p></blockquote><h2 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h2><p>状态转移方程dp[i][j]:以i，j为右下角的最大正方形边长</p><h2 id="代码编写：-2"><a href="#代码编写：-2" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j ==<span class="hljs-number">0</span> )&#123;<br>                        dp[i][j]=<span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i<span class="hljs-number">-1</span>][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i][j<span class="hljs-number">-1</span>]&#125;)<span class="hljs-number">+1</span>;<br>                    &#125;<br>                    res = <span class="hljs-built_in">max</span>(dp[i][j],res);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res*res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大厂笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月14日hot100练习</title>
    <link href="/2025/03/14/20250314-hot100/"/>
    <url>/2025/03/14/20250314-hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。算法的时间复杂度应该为 O(log (m+n)) 。<br>示例 1：<br>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2</p><p>示例 2：<br>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><h2 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h2><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为<code>O(log n)</code>的算法解决此问题。</p><h2 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h2><p>思路1：一个o(n)解法：<br>a.找到单调下降的索引位置,记作k，然后[begin,k]全部reverse<br>b.再使用二分查找法进行查找<br>思路2：O(log n)解法<br>a.确认是升序区间还是乱序区间[left,mid],[mid,right]<br>b.根据target与区间端值进行比较，判断在左半区间还是右边的区间，进行区间收缩<br>c.循环1.2步</p><h2 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">//确认是升序区间还是乱序区间[left,mid][mid,right]</span><br>        <span class="hljs-comment">//根据target与left进行比较，判断在左半区间还是右边的区间</span><br>        <span class="hljs-comment">//循环1.2步</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[left]&lt;=nums[mid])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])<br>                &#123;<br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    left = mid<span class="hljs-number">+1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right])<br>                &#123;<br>                    left = mid<span class="hljs-number">+1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为<code>O(log n)</code>的算法解决此问题。</p><h2 id="思路分析：-2"><a href="#思路分析：-2" class="headerlink" title="思路分析："></a>思路分析：</h2><p>a.首先找到数组中第一个等于target的位置<br>b.再找到数组中第一个大于target的位置<br>c.进行返回值的检查</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchLeftBoundary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;  <span class="hljs-comment">// 找左边界，nums[mid] == target 也要往左找</span><br>                right = mid - <span class="hljs-number">1</span>;<br>                res = mid;  <span class="hljs-comment">// 记录当前可能的左边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchRightBoundary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;  <span class="hljs-comment">// 找右边界，nums[mid] == target 也要往右找</span><br>                left = mid + <span class="hljs-number">1</span>;<br>                res = mid;  <span class="hljs-comment">// 记录当前可能的右边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 处理空数组情况</span><br><br>        <span class="hljs-type">int</span> leftRange = <span class="hljs-built_in">searchLeftBoundary</span>(nums, target);<br>        <span class="hljs-type">int</span> rightRange = <span class="hljs-built_in">searchRightBoundary</span>(nums, target);<br><br>        <span class="hljs-comment">// 检查是否真正找到了 target</span><br>        <span class="hljs-keyword">if</span> (leftRange == <span class="hljs-number">-1</span> || rightRange == <span class="hljs-number">-1</span> || nums[leftRange] != target || nums[rightRange] != target) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <br>        res[<span class="hljs-number">0</span>] = leftRange;<br>        res[<span class="hljs-number">1</span>] = rightRange;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="240-搜索二维矩阵"><a href="#240-搜索二维矩阵" class="headerlink" title="240.搜索二维矩阵"></a>240.搜索二维矩阵</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。<br>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5<br>输出：true</li></ul><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>选取右上角为搜索初值，当<code>matrix[row][col]&gt;target</code>时，代表col要收缩一个，如果<code>matrix[row][col]&lt; target</code>,代表row要增加</p><h2 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> cols = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col = cols;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(row&lt;=rows &amp;&amp; col&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[row][col] == target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col]&gt;target)<br>            &#123;<br>                col--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                row++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h1><h2 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。<br>示例 1:</p><blockquote><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h2 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h2><p>a.如果没有重复子串，则向右生长，否则收缩左边界</p><h2 id="代码编写：-2"><a href="#代码编写：-2" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br><br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; umap;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> head = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            head = <span class="hljs-built_in">max</span>(head,umap[s[i]]);<br>            umap[s[i]] = i<span class="hljs-number">+1</span>;<br>            res = <span class="hljs-built_in">max</span>(res,i-head<span class="hljs-number">+1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode-hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月13日hot100练习</title>
    <link href="/2025/03/14/20250313-hot100/"/>
    <url>/2025/03/14/20250313-hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</li><li>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。</li><li>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</li></ul><p>必须<code>原地</code>修改，只允许使用额外常数空间。</p><p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]</p><p>示例 2：<br>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]</p><p>示例 3：<br>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1]</p><h2 id="解题要点"><a href="#解题要点" class="headerlink" title="解题要点"></a>解题要点</h2><p>a.首先从后往前遍历，找到一个升序的邻点,记作k-1,k；<br>b.然后继续从后往前找，找到一个比k-1索引处值比k-1处值小的点，记作j；<br>c.然后将[k,end]区间全部翻转；</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> o =  k;<br>        <span class="hljs-comment">//找到第一个相邻数组升序的</span><br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span> &amp;&amp; nums[k<span class="hljs-number">-1</span>]&gt;=nums[k]) k--;<br>        <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//找到第一个比他大</span><br>            <span class="hljs-keyword">while</span>(nums[k<span class="hljs-number">-1</span>]&gt;=nums[o]) o--;<br>            <span class="hljs-built_in">swap</span>(nums[k<span class="hljs-number">-1</span>],nums[o]);<br>            <span class="hljs-comment">//然后后续全部升序</span><br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+k,nums.<span class="hljs-built_in">end</span>());<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个 n × n 的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在<code>原地</code>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。<br>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>对于matrix矩阵的四个角,n*n<br>    (i,j)a————b(j,n-i-1)<br>         |    |<br>         |    |<br>(n-j-1,i)c————d(n-i-1,n-j-1)<br>赋值顺序：c–&gt;a,d–&gt;c,b–&gt;d,a–&gt;b</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m/<span class="hljs-number">2</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;(n<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;j++)<br>            &#123;<br>                <span class="hljs-type">int</span> val = matrix[i][j];<br>                matrix[i][j] = matrix[n - j <span class="hljs-number">-1</span>][i];<br>                matrix[n - j <span class="hljs-number">-1</span>][i] = matrix[m - i <span class="hljs-number">-1</span>][n - j <span class="hljs-number">-1</span>];<br>                matrix[m - i <span class="hljs-number">-1</span>][n - j <span class="hljs-number">-1</span>] = matrix[j][m - i <span class="hljs-number">-1</span>];<br>                matrix[j][m - i <span class="hljs-number">-1</span>] = val;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p><h2 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h2><p>定义一个哈希数组和返回值，然后对数组添加进哈希表中，更新返回值，其中当频率大于n&#x2F;2时，直接返回res</p><h2 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sz = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxFre = INT_MIN;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)<br>        &#123;<br>            map[nums[i]]++;<br>            <span class="hljs-keyword">if</span>(map[nums[i]]&gt;maxFre)<br>            &#123;<br>                maxFre = <span class="hljs-built_in">max</span>(maxFre,map[nums[i]]);<br>                res = nums[i];<br>                <span class="hljs-keyword">if</span>(maxFre&gt;sz/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><h2 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h2><p>建立一个大小为k的堆，然后对其进行维护，当数组添加维护完毕，将堆的堆顶元素推出</p><h2 id="代码编写：-2"><a href="#代码编写：-2" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>       priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;&gt;&gt; q;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:nums)<br>       &#123;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>()&lt;k)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(num);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">top</span>()&lt;num)<br>            &#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>                q.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>#给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在32 位 整数范围内。请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><h2 id="解题思路：-3"><a href="#解题思路：-3" class="headerlink" title="解题思路："></a>解题思路：</h2><p>使用后缀乘积和后缀乘积进行编写,其前缀和后缀乘积有如下关系：<br>pre[i]&#x3D;pre[i-1]*num[i-1];<br>suf[i]&#x3D;suf[i-1]*num[i-1];<br>因此对于数组中某个元素除自身外的乘积可由下式进行计算：<br>res[i]&#x3D;pre[i]*suf[i];</p><h2 id="代码编写：-3"><a href="#代码编写：-3" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(nums.size(),<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">suf</span><span class="hljs-params">(nums.size(),<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            pre[i] = pre[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>        &#123;<br>            suf[j] = suf[j<span class="hljs-number">+1</span>]*nums[j<span class="hljs-number">+1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;nums.<span class="hljs-built_in">size</span>();k++)<br>        &#123;<br>            res[k] = pre[k]*suf[k];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="448-找到所有消失的数字"><a href="#448-找到所有消失的数字" class="headerlink" title="448.找到所有消失的数字"></a>448.找到所有消失的数字</h1><h2 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。<br>示例 1：<br>输入：nums &#x3D; [4,3,2,7,8,2,3,1]<br>输出：[5,6]<br>示例 2：<br>输入：nums &#x3D; [1,1]<br>输出：[2]</p><h2 id="解题思路：-4"><a href="#解题思路：-4" class="headerlink" title="解题思路："></a>解题思路：</h2><p>建立一个大小为n的哈希数组，然后维护哈希数组；维护结束后遍历哈希数组，对于未被更新的值，其对应的索引推入结果数组中。</p><h2 id="代码编写：-4"><a href="#代码编写：-4" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:nums)<br>        &#123;<br>            flag[num]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flag[i]==<span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h1><h2 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><h2 id="解题思路：-5"><a href="#解题思路：-5" class="headerlink" title="解题思路："></a>解题思路：</h2><p>由n&amp;(n-1)可得到n最右边的二进制1消除，等价于n比n&amp;(n-1)的二进制位多一个1，因此可更新如下状态方程：<br>dp[n]&#x3D;dp[n&amp;(n-1)]+1;</p><h2 id="代码编写：-5"><a href="#代码编写：-5" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            dp[i]=dp[i&amp;(i<span class="hljs-number">-1</span>)]<span class="hljs-number">+1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><h2 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><h2 id="解题思路：-6"><a href="#解题思路：-6" class="headerlink" title="解题思路："></a>解题思路：</h2><p>由如下性质a^a&#x3D;0;a^0&#x3D;a；可解出只出现一次的数字：</p><h2 id="代码描述："><a href="#代码描述：" class="headerlink" title="代码描述："></a>代码描述：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:nums)<br>        &#123;<br>            r^=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h1><h2 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h2><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离</p><h2 id="解题思路：-7"><a href="#解题思路：-7" class="headerlink" title="解题思路："></a>解题思路：</h2><p>可由c&#x3D;a^b得出二进制不同的位置数目，然后由c&#x3D;c&amp;(c-1)得出二进制1的个数；</p><h2 id="代码编写：-6"><a href="#代码编写：-6" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> t = x^y;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(t)<br>        &#123;<br>            res++;<br>            t = t&amp;(t<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode-hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月12日hot100练习</title>
    <link href="/2025/03/13/20250312-hot100/"/>
    <url>/2025/03/13/20250312-hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br>示例1：<br>输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,8,0,7]<br>示例2：<br>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[8,0,7]<br>示例3：<br>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p><h2 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    ListNode* next;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-built_in">ListNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>():<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        ListNode* nex = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur)<br>        &#123;<br>            nex = cur-&gt;next;<br><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;   <br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoListByCarry</span><span class="hljs-params">(ListNode* a,ListNode* b,<span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-literal">nullptr</span> &amp;&amp; b == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> carry?<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry):<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(a-&gt;next) <span class="hljs-built_in">swap</span>(a,b);<br><br>        carry += a-&gt;val + b?b-&gt;val:<span class="hljs-number">0</span>;<br>        a-&gt;val = carry % <span class="hljs-number">10</span>;<br>        a-&gt;next = <span class="hljs-built_in">mergeTwoListByCarry</span>(a-&gt;next,b?b-&gt;next:<span class="hljs-literal">nullptr</span>,carry/<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* nl1 = <span class="hljs-built_in">reverseList</span>(l1);<br>        ListNode* nl2 = <span class="hljs-built_in">reverseList</span>(l2);<br>        ListNode* res = <span class="hljs-built_in">mergeTwoListByCarry</span>(ListNode* a,ListNode* b,<span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个大小为<code>m x n</code>的二进制矩阵 grid 。岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的<code>「相邻」</code>要求两个 1 必须在<code>水平或者竖直的四个方向上</code>相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。<br>示例一：<br>输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>输出：6<br>解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flag,<span class="hljs-type">int</span>&amp; curArea)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> row = x + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> col = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(row&gt;=<span class="hljs-number">0</span> &amp;&amp; row&lt;grid.<span class="hljs-built_in">size</span>() &amp;&amp; col&gt;=<span class="hljs-number">0</span> &amp;&amp; col&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[row][col])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(flag[row][col] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                flag[row][col] = <span class="hljs-number">1</span>;<br>                curArea++;<br>                <span class="hljs-built_in">bfs</span>(grid,row,col,flag,curArea);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">flag</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(flag[i][j] == <span class="hljs-number">0</span> &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>)<br>                &#123;<br>                    flag[i][j] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> curArea = <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">bfs</span>(grid,i,j,flag,curArea);<br>                    maxArea = <span class="hljs-built_in">max</span>(maxArea,curArea);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。</p><h2 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || (x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> &amp;&amp; x!=<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> origin = x;<br>       <span class="hljs-keyword">while</span>(x&gt;reverse)<br>       &#123;<br>            <span class="hljs-type">int</span> digit = x%<span class="hljs-number">10</span>;<br>            reverse = reverse*<span class="hljs-number">10</span> + digit;<br>            x/=<span class="hljs-number">10</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> x == reverse || x == reverse / <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><h2 id="代码编写：-2"><a href="#代码编写：-2" class="headerlink" title="代码编写："></a>代码编写：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(que.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> sz = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; array;<br>            <span class="hljs-keyword">while</span>(sz--)<br>            &#123;<br>                TreeNode* cur = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                array.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(array);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode-hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月12日网络编程八股文</title>
    <link href="/2025/03/12/interByCpp/"/>
    <url>/2025/03/12/interByCpp/</url>
    
    <content type="html"><![CDATA[<h1 id="01-为什么使用epoll"><a href="#01-为什么使用epoll" class="headerlink" title="01.为什么使用epoll"></a>01.为什么使用epoll</h1>]]></content>
    
    
    <categories>
      
      <category>C++八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月12日海康面试</title>
    <link href="/2025/03/12/20250312-1/"/>
    <url>/2025/03/12/20250312-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-模板（Templates）-vs-多态（Polymorphism）"><a href="#C-模板（Templates）-vs-多态（Polymorphism）" class="headerlink" title="C++ 模板（Templates） vs 多态（Polymorphism）"></a>C++ 模板（Templates） vs 多态（Polymorphism）</h1><h2 id="1-什么是-C-模板？"><a href="#1-什么是-C-模板？" class="headerlink" title="1. 什么是 C++ 模板？"></a>1. 什么是 C++ 模板？</h2><p>C++ <strong>模板（Templates）</strong> 是 <strong>编译时泛型编程（Generic Programming）</strong>，允许生成不同类型的代码。</p><h3 id="示例：函数模板"><a href="#示例：函数模板" class="headerlink" title="示例：函数模板"></a><strong>示例：函数模板</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;       <span class="hljs-comment">// 调用 int 版本</span><br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>) &lt;&lt; endl;   <span class="hljs-comment">// 调用 double 版本</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>编译时展开：编译器为 int 和 double 生成不同版本的 add()。</li><li>不使用 vtable，没有运行时动态分派。</li></ul><h1 id="C-std-map-的-Key-是否可以使用结构体？"><a href="#C-std-map-的-Key-是否可以使用结构体？" class="headerlink" title="C++ std::map 的 Key 是否可以使用结构体？"></a>C++ std::map 的 Key 是否可以使用结构体？</h1><p>✅ 是的，<code>std::map </code>的 <code>key </code>可以使用结构体，但需要满足以下条件：</p><ol><li>必须提供<code> &lt;（小于号运算符）</code>或 <code>std::less&lt;T&gt; </code>比较规则，因为 std::map 需要排序 key。</li><li>结构体必须是<code>可拷贝</code>和<code>可移动</code>的（默认 std::map 需要复制 key）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体作为 `std::map` 的 Key</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br><br>    <span class="hljs-comment">// 必须提供 `&lt;` 运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (x != other.x) <span class="hljs-keyword">return</span> x &lt; other.x;<br>        <span class="hljs-keyword">return</span> y &lt; other.y;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;Point, string&gt; pointMap;<br><br>    <span class="hljs-comment">// 插入数据</span><br>    pointMap[&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;] = <span class="hljs-string">&quot;A&quot;</span>;<br>    pointMap[&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;] = <span class="hljs-string">&quot;B&quot;</span>;<br>    pointMap[&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;] = <span class="hljs-string">&quot;C&quot;</span>;<br><br>    <span class="hljs-comment">// 遍历输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : pointMap) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Point(&quot;</span> &lt;&lt; key.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; key.y &lt;&lt; <span class="hljs-string">&quot;) -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="STL的六大组件"><a href="#STL的六大组件" class="headerlink" title="STL的六大组件"></a>STL的六大组件</h1><p>C++ STL（Standard Template Library，标准模板库）的六大组件 是 STL 的核心组成部分，它们分别是：<br>✅ 容器（Containers）作用： 存储和管理数据，是 STL 的核心部分。<br>✅ 算法（Algorithms）作用： 提供排序、查找、修改、计算等常见算法。<br>✅ 迭代器（Iterators）作用：在容器和算法之间提供统一的访问接口，使 STL 算法能够适用于不同容器。<br>✅ 仿函数（Functors）作用： 类似函数的对象，可以在 std::sort() 等 STL 算法中自定义比较规则。<br>✅ 适配器（Adapters）作用： 修改 STL 组件的行为。<br>✅ 分配器（Allocators）作用： 负责管理内存的分配和释放，通常使用默认 allocator<T>，但可以自定义。</T></p>]]></content>
    
    
    <categories>
      
      <category>大厂面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能计算岗位-cuda基础知识</title>
    <link href="/2025/03/11/cuda-basic/"/>
    <url>/2025/03/11/cuda-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="CUDA的线程组织结构"><a href="#CUDA的线程组织结构" class="headerlink" title="CUDA的线程组织结构"></a>CUDA的线程组织结构</h3><p>CUDA 的线程执行模型基于 SIMT（Single Instruction, Multiple Thread） 结构，采用层级化的线程组织方式，主要包括 Grid（网格）、Block（线程块）、Thread（线程） 三个层级。</p><h4 id="1-线程层级结构"><a href="#1-线程层级结构" class="headerlink" title="1. 线程层级结构"></a>1. 线程层级结构</h4><p>在 CUDA 中，线程的组织结构如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">Grid</span>（网格）<br> ├── Block(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)  ├── Block(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  ├── Block(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) ...<br> │     ...<br> ├── Block(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)  ├── Block(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)  ├── Block(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) ...<br> │     ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)  ├── <span class="hljs-built_in">Thread</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) ...<br> │     ...<br><br></code></pre></td></tr></table></figure><p>CUDA 线程层次：</p><p><strong>Grid（网格）</strong>：</p><ul><li>由多个 Block（线程块） 组成</li><li>Block 数量可以是一维、二维或三维</li></ul><p><strong>Block（线程块）</strong>：</p><ul><li>由多个 Thread（线程） 组成</li><li>每个 Block 共享一块共享内存（Shared Memory）</li><li>线程之间可以使用 __syncthreads() 同步</li></ul><p><strong>Thread（线程）</strong>：</p><ul><li>每个线程有自己的 寄存器（Register）</li><li>线程执行相同的 Kernel 代码，但操作不同的数据</li></ul><hr><h4 id="2-CUDA-线程索引"><a href="#2-CUDA-线程索引" class="headerlink" title="2. CUDA 线程索引"></a>2. CUDA 线程索引</h4><h2 id="CUDA-提供了线程索引（Thread-Indexing）-来标识每个线程的位置。3D-线程索引："><a href="#CUDA-提供了线程索引（Thread-Indexing）-来标识每个线程的位置。3D-线程索引：" class="headerlink" title="CUDA 提供了线程索引（Thread Indexing） 来标识每个线程的位置。3D 线程索引："></a>CUDA 提供了线程索引（Thread Indexing） 来标识每个线程的位置。<br>3D 线程索引：<br><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml">int <span class="hljs-variable language_">x</span> = threadIdx.<span class="hljs-variable language_">x</span> + blockIdx.<span class="hljs-variable language_">x</span> * blockDim.<span class="hljs-variable language_">x</span>;<br>int <span class="hljs-variable language_">y</span> = threadIdx.<span class="hljs-variable language_">y</span> + blockIdx.<span class="hljs-variable language_">y</span> * blockDim.<span class="hljs-variable language_">y</span>;<br>int z = threadIdx.z + blockIdx.z * blockDim.z;<br></code></pre></td></tr></table></figure></h2><h4 id="3-线程块和线程调度"><a href="#3-线程块和线程调度" class="headerlink" title="3. 线程块和线程调度"></a>3. 线程块和线程调度</h4><p><strong>SM（流式多处理器）调度</strong></p><ul><li>一个 GPU 由多个 SM 组成</li><li>每个 SM 可同时执行多个 Block</li><li>Block 内的线程以 Warp（32 个线程）为单位执行</li></ul><hr><h4 id="4-优化策略"><a href="#4-优化策略" class="headerlink" title="4. 优化策略"></a>4. 优化策略</h4><ul><li>合理组织 Grid 和 Block，保证最大计算吞吐量</li><li>使用 Shared Memory，减少全局内存访问</li><li>优化 Memory Coalescing，提高带宽利用率</li><li>避免 Warp 线程分支，提升计算效率</li></ul><h3 id="CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用"><a href="#CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用" class="headerlink" title="CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用"></a>CUDA的存储体系结构，每一种存储的优缺点，该如何合理使用</h3><p>CUDA 主要有以下几种存储类型：</p><h3 id="CUDA-stream的概念，为什么要使用多个stream？"><a href="#CUDA-stream的概念，为什么要使用多个stream？" class="headerlink" title="CUDA stream的概念，为什么要使用多个stream？"></a>CUDA stream的概念，为什么要使用多个stream？</h3><h4 id="CUDA-Stream-的概念"><a href="#CUDA-Stream-的概念" class="headerlink" title="CUDA Stream 的概念"></a>CUDA Stream 的概念</h4><h4 id="1-什么是-CUDA-Stream？"><a href="#1-什么是-CUDA-Stream？" class="headerlink" title="1. 什么是 CUDA Stream？"></a>1. 什么是 CUDA Stream？</h4><p>CUDA <strong>Stream（流）</strong> 是 <strong>一个有序的 GPU 任务执行队列</strong>，其中的任务按顺序执行。多个 Stream 之间可以<strong>并行执行</strong>，从而提高 GPU 的计算效率。</p><h4 id="2-CUDA-Stream-的关键特点"><a href="#2-CUDA-Stream-的关键特点" class="headerlink" title="2. CUDA Stream 的关键特点"></a>2. CUDA Stream 的关键特点</h4><ul><li><strong>FIFO 方式</strong>：Stream 内的任务 <strong>按顺序执行</strong></li><li><strong>多个 Stream 并行</strong>：不同的 Stream 任务可以同时执行</li><li><strong>异步执行</strong>：允许计算和数据传输并行，提高 GPU 利用率</li><li><strong>减少 CPU-GPU 同步开销</strong>：避免 <code>cudaDeviceSynchronize()</code> 造成的阻塞</li></ul><hr><h4 id="3-为什么要使用多个-Stream？"><a href="#3-为什么要使用多个-Stream？" class="headerlink" title="3. 为什么要使用多个 Stream？"></a>3. 为什么要使用多个 Stream？</h4><p><strong>问题：单个 Stream 计算和数据传输串行执行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cudaMemcpy</span>(d_data, h_data, size, cudaMemcpyHostToDevice);  <span class="hljs-comment">// 数据拷贝（同步）</span><br>kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_data);  <span class="hljs-comment">// 核函数计算（需等待数据拷贝完成）</span><br><span class="hljs-built_in">cudaMemcpy</span>(h_data, d_data, size, cudaMemcpyDeviceToHost);  <span class="hljs-comment">// 数据拷贝（计算完成后）</span><br>cudaStream_t stream1, stream2;<br><span class="hljs-built_in">cudaStreamCreate</span>(&amp;stream1);<br><span class="hljs-built_in">cudaStreamCreate</span>(&amp;stream2);<br><br><span class="hljs-comment">// Stream 1 进行数据拷贝 + 计算</span><br><span class="hljs-built_in">cudaMemcpyAsync</span>(d_data1, h_data1, size, cudaMemcpyHostToDevice, stream1);<br>kernel&lt;&lt;&lt;grid, block, <span class="hljs-number">0</span>, stream1&gt;&gt;&gt;(d_data1);<br><span class="hljs-built_in">cudaMemcpyAsync</span>(h_data1, d_data1, size, cudaMemcpyDeviceToHost, stream1);<br><br><span class="hljs-comment">// Stream 2 进行数据拷贝 + 计算</span><br><span class="hljs-built_in">cudaMemcpyAsync</span>(d_data2, h_data2, size, cudaMemcpyHostToDevice, stream2);<br>kernel&lt;&lt;&lt;grid, block, <span class="hljs-number">0</span>, stream2&gt;&gt;&gt;(d_data2);<br><span class="hljs-built_in">cudaMemcpyAsync</span>(h_data2, d_data2, size, cudaMemcpyDeviceToHost, stream2);<br><br><span class="hljs-comment">// 等待所有 Stream 完成</span><br><span class="hljs-built_in">cudaDeviceSynchronize</span>();<br></code></pre></td></tr></table></figure><h4 id="4-CUDA-Stream-典型应用场景"><a href="#4-CUDA-Stream-典型应用场景" class="headerlink" title="4. CUDA Stream 典型应用场景"></a>4. CUDA Stream 典型应用场景</h4><p>✅ 1. 计算与数据传输并行<br>使用多个 Stream 让数据传输和计算同时进行，减少等待时间。</p><p>✅ 2. 并行执行多个 Kernel<br>适用于批量数据处理，如深度学习、图像处理等。</p><p>✅ 3. 提高吞吐量<br>适用于需要连续处理大量数据的应用，如视频流处理、点云计算等。</p><hr><h3 id="GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势"><a href="#GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势" class="headerlink" title="GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势"></a>GPU和CPU分别适合执行哪些程序？结合它们的硬件架构解释一下为什么它们有各自的优势</h3><h4 id="GPU-和-CPU-的适用场景及架构优势"><a href="#GPU-和-CPU-的适用场景及架构优势" class="headerlink" title="GPU 和 CPU 的适用场景及架构优势"></a>GPU 和 CPU 的适用场景及架构优势</h4><h4 id="1-GPU-和-CPU-适合执行的程序类型"><a href="#1-GPU-和-CPU-适合执行的程序类型" class="headerlink" title="1. GPU 和 CPU 适合执行的程序类型"></a>1. <strong>GPU 和 CPU 适合执行的程序类型</strong></h4><table><thead><tr><th><strong>处理器</strong></th><th><strong>适合执行的任务</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>CPU（中央处理器）</strong></td><td><strong>复杂逻辑、多任务并发、顺序计算、低延迟任务</strong></td><td>操作系统、数据库、AI 逻辑处理、复杂决策、Web 服务器</td></tr><tr><td><strong>GPU（图形处理器）</strong></td><td><strong>大规模并行计算、数据密集型任务、高吞吐量计算</strong></td><td>深度学习训练、3D 渲染、图像处理、物理仿真、科学计算</td></tr></tbody></table><hr><h4 id="2-CPU-和-GPU-的硬件架构对比"><a href="#2-CPU-和-GPU-的硬件架构对比" class="headerlink" title="2. CPU 和 GPU 的硬件架构对比"></a>2. <strong>CPU 和 GPU 的硬件架构对比</strong></h4><h4 id="✅-1️⃣-CPU（中央处理器）的架构特点"><a href="#✅-1️⃣-CPU（中央处理器）的架构特点" class="headerlink" title="✅ 1️⃣ CPU（中央处理器）的架构特点"></a><strong>✅ 1️⃣ CPU（中央处理器）的架构特点</strong></h4><p><strong>CPU 的架构设计主要围绕“低延迟”和“复杂指令处理”</strong>，它的架构特点如下：</p><ul><li><strong>少量高性能核心（Cores）</strong></li><li><strong>高主频（GHz 级别），单核性能强</strong></li><li><strong>复杂的缓存层次（L1、L2、L3）</strong>，降低访存延迟</li><li><strong>支持分支预测和乱序执行</strong>，适合复杂的逻辑控制</li><li><strong>强大的指令集（x86、ARM）</strong>，适用于多种任务</li></ul><p>📌 <strong>CPU 适合的任务</strong></p><ul><li><strong>顺序计算任务</strong>（如执行 if-else、递归）</li><li><strong>多任务并发</strong>（如运行多个进程、操作系统调度）</li><li><strong>低延迟计算</strong>（如数据库查询、HTTP 请求处理）</li><li><strong>逻辑控制密集型任务</strong>（如操作系统、编译器）</li></ul><p>🔹 <strong>示例：CPU 适合的任务</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 递归计算斐波那契数列（CPU 擅长处理）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="✅-2️⃣-GPU（图形处理器）的架构特点"><a href="#✅-2️⃣-GPU（图形处理器）的架构特点" class="headerlink" title="✅ 2️⃣ GPU（图形处理器）的架构特点"></a><strong>✅ 2️⃣ GPU（图形处理器）的架构特点</strong></h4><p>GPU 的架构设计主要围绕“高吞吐量”和“大规模并行计算”，它的架构特点如下：</p><ul><li>大量并行计算核心（上千个 CUDA 核心）</li><li>较低主频，但极强的并行计算能力</li><li>SIMT（单指令多线程）架构，适合大规模数据并行</li><li>高带宽显存（GDDR6&#x2F;HBM）适合流式数据处理</li><li>优化的矩阵计算单元（Tensor Cores），适合深度学习训练<br>📌 GPU 适合的任务</li></ul><p>并行计算任务（如矩阵运算、点云处理）<br>数据密集型任务（如图像处理、物理仿真）<br>AI 和深度学习（如神经网络训练和推理）<br>高吞吐量计算（如 3D 渲染、视频编解码）<br>🔹 示例：GPU 适合的任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CUDA 计算向量加法（GPU 并行计算）</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">vectorAdd</span><span class="hljs-params">(<span class="hljs-type">float</span> *A, <span class="hljs-type">float</span> *B, <span class="hljs-type">float</span> *C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-type">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;<br>    <span class="hljs-keyword">if</span> (tid &lt; N) &#123;<br>        C[tid] = A[tid] + B[tid];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="平时如何进行kernel的优化，会用到哪些工具？"><a href="#平时如何进行kernel的优化，会用到哪些工具？" class="headerlink" title="平时如何进行kernel的优化，会用到哪些工具？"></a>平时如何进行kernel的优化，会用到哪些工具？</h4><h5 id="CUDA-Kernel-优化方法与工具"><a href="#CUDA-Kernel-优化方法与工具" class="headerlink" title="CUDA Kernel 优化方法与工具"></a>CUDA Kernel 优化方法与工具</h5><h6 id="1-Kernel-优化的主要策略"><a href="#1-Kernel-优化的主要策略" class="headerlink" title="1. Kernel 优化的主要策略"></a>1. Kernel 优化的主要策略</h6><p>CUDA Kernel 的优化可以从 <strong>计算效率、内存访问效率</strong> 和 <strong>并行度</strong> 三个方面进行提升。</p><h6 id="1-1-计算效率优化"><a href="#1-1-计算效率优化" class="headerlink" title="1.1 计算效率优化"></a><strong>1.1 计算效率优化</strong></h6><p>✅ <strong>减少分支分歧（Branch Divergence）</strong></p><ul><li>避免 <code>if-else</code> 结构导致的 Warp 线程分歧</li><li>例如，将 <code>if</code> 语句改为<strong>掩码操作</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value = (condition) ? a : b;  <span class="hljs-comment">// 避免 Warp 内线程执行不同路径</span><br></code></pre></td></tr></table></figure>✅ 提高 Warp 利用率</li><li>每个 Warp（32 线程）应尽可能全部执行，避免计算资源浪费</li><li>选择合适的 Block&#x2F;Thread 组织方式，填满 GPU 计算单元，网格大小是数据集大小除以线程块大小的商。<br>✅ 使用寄存器优化计算</li><li>尽量减少本地内存（Local Memory）使用，避免全局内存访问</li><li>使用 nvcc –ptxas-options&#x3D;-v 检查寄存器使用情况<br>1.2 内存访问优化<br>✅ 优化 Memory Coalescing（内存合并访问）</li><li>全局内存访问应对齐，确保线程按顺序访问连续内存<br>✅ 利用 Shared Memory（共享内存）</li><li>共享内存比全局内存快 100 倍，适合线程块内数据交换</li><li>需要避免 Bank Conflict（存储体冲突） 使用padding进行异或操作<br>✅ 使用 Texture Memory（纹理内存）优化读取</li><li>适用于二维或三维数据访问</li><li>纹理内存支持缓存，提高读取速度<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*resDesc 和 texDesc 代表什么意思？</span><br><span class="hljs-comment">resDesc（资源描述符，Resource Descriptor）：</span><br><span class="hljs-comment">定义 纹理数据的来源（如 CUDA 设备内存）。</span><br><span class="hljs-comment">指定数据格式（如 cudaChannelFormatDesc）。</span><br><span class="hljs-comment">texDesc（纹理描述符，Texture Descriptor）：</span><br><span class="hljs-comment">定义 纹理的行为（如插值模式、地址模式）。</span><br><span class="hljs-comment">设定访问模式（如 cudaFilterModeLinear 支持双线性插值）。*/</span><br>cudaTextureObject_t texObj;<br>cudaResourceDesc resDesc;<br>cudaTextureDesc texDesc;<br>cudaArray_t d_array;<br><br><span class="hljs-comment">// 1. 设置资源描述符</span><br><span class="hljs-built_in">memset</span>(&amp;resDesc, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(resDesc));<br>resDesc.resType = cudaResourceTypeArray;<br>resDesc.res.array.array = d_array;  <span class="hljs-comment">// 绑定 CUDA 数组</span><br><br><span class="hljs-comment">// 2. 设置纹理描述符</span><br><span class="hljs-built_in">memset</span>(&amp;texDesc, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(texDesc));<br>texDesc.addressMode[<span class="hljs-number">0</span>] = cudaAddressModeWrap;  <span class="hljs-comment">// 地址模式</span><br>texDesc.addressMode[<span class="hljs-number">1</span>] = cudaAddressModeWrap;<br>texDesc.filterMode = cudaFilterModeLinear;  <span class="hljs-comment">// 线性插值模式</span><br>texDesc.readMode = cudaReadModeElementType;  <span class="hljs-comment">// 读取原始数据</span><br><span class="hljs-comment">// 3. 创建纹理对象</span><br><span class="hljs-built_in">cudaCreateTextureObject</span>(&amp;texObj, &amp;resDesc, &amp;texDesc, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>1.3 提高并行度<br>✅ 调整 Grid 和 Block 大小</li><li>选择合适的 Block 维度，提高 SM 利用率<br>例如，2D 任务可使用 dim3 gridDim, blockDim<br>✅ 优化 Kernel 计算负载</li><li>避免过多的 Kernel 启动开销</li><li>尽量在 Kernel 内部执行更多计算，减少 CPU-GPU 交互<br><a href="https://blog.csdn.net/LostUnravel/article/details/135721041">https://blog.csdn.net/LostUnravel/article/details/135721041</a><br>✅ 对于block_size<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">最好是不小于 SM 上最大同时执行的线程数(Maximum number of resident threads per SM)和最大同时执行的线程块数(Maximum number of resident blocks per SM)的比值.<br>因为要尽可能让 GPU 占有率(Occupancy, SM 上并发执行的线程数和 SM 上最大支持的线程数的比值)达到 <span class="hljs-number">100%</span><br>!<span class="hljs-selector-attr">[alt text]</span>(image.png)<br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">寄存器、共享内存等资源对应到每个线程不能超过上限(每个 <span class="hljs-built_in">block</span> 的 <span class="hljs-number">32</span> 位寄存器数量, 每个 <span class="hljs-built_in">block</span> 的共享内存大小上限). 这里指明为<span class="hljs-string">&quot;对应到每个线程&quot;</span>, 即每个线程所使用的寄存器数、共享内存应小于上限/ block_size.<br></code></pre></td></tr></table></figure>✅ 对于grid_size（总的线程数量）</li><li>其应 SM 数量 * 每个 SM 最大 block 数个 block<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stan">因为每个 <span class="hljs-built_in">block</span> 的计算量相等，所以所有 SM 应几乎同时完成这些 <span class="hljs-built_in">block</span> 的计算，然后处理下一批，这其中的每一批被称之为一个 wave。想象如果 grid_size 恰好比一个 wave 多出一个 <span class="hljs-built_in">block</span>，因为 stream 上的下个 kernel 要等这个 kernel 完全执行完成后才能开始执行，所以第一个 wave 完成后，GPU 上将只有一个 <span class="hljs-built_in">block</span> 在执行，GPU 的实际利用率会很低，这种情况被称之为 <span class="hljs-built_in">tail</span> effect，我们应尽量避免这种情况。将 grid_size 设置为精确的一个 wave 可能也无法避免 <span class="hljs-built_in">tail</span> effect，因为 GPU 可能不是被当前 stream 独占的，常见的如 NCCL 执行时会占用一些 SM。<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="cuda矩阵乘法"><a href="#cuda矩阵乘法" class="headerlink" title="cuda矩阵乘法"></a>cuda矩阵乘法</h3><h4 id="1-原始版本"><a href="#1-原始版本" class="headerlink" title="1.原始版本"></a>1.原始版本</h4><ul><li>直接使用全局内存进行矩阵乘法的运算<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE 16  <span class="hljs-comment">// 线程块大小，控制并行度</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// **CUDA 核函数**：执行矩阵乘法 C = A * B</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">matrixMulKernel</span><span class="hljs-params">(<span class="hljs-type">float</span> *A, <span class="hljs-type">float</span> *B, <span class="hljs-type">float</span> *C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-comment">// 计算当前线程在网格中的全局索引</span><br>    <span class="hljs-type">int</span> row = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-type">int</span> col = blockIdx.x * blockDim.x + threadIdx.x;<br><br>    <span class="hljs-type">float</span> sum = <span class="hljs-number">0.0f</span>;<br>    <br>    <span class="hljs-comment">// **确保线程索引在矩阵范围内**</span><br>    <span class="hljs-keyword">if</span> (row &lt; N &amp;&amp; col &lt; N) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; N; ++k) &#123;<br>            sum += A[row * N + k] * B[k * N + col];<br>        &#125;<br>        C[row * N + col] = sum;  <span class="hljs-comment">// 赋值到结果矩阵</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// **主机端代码**（CPU 端）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matrixMultiplication</span><span class="hljs-params">(<span class="hljs-type">float</span> *h_A, <span class="hljs-type">float</span> *h_B, <span class="hljs-type">float</span> *h_C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = N * N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>    <span class="hljs-type">float</span> *d_A, *d_B, *d_C;<br><br>    <span class="hljs-comment">// **分配 GPU 内存**</span><br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_A, size);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_B, size);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_C, size);<br><br>    <span class="hljs-comment">// **复制数据到 GPU**</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_A, h_A, size, cudaMemcpyHostToDevice);<br>    <span class="hljs-built_in">cudaMemcpy</span>(d_B, h_B, size, cudaMemcpyHostToDevice);<br><br>    <span class="hljs-comment">// **设置 CUDA 线程块和网格**</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">threadsPerBlock</span><span class="hljs-params">(BLOCK_SIZE, BLOCK_SIZE)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">blocksPerGrid</span><span class="hljs-params">((N + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE, (N + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE)</span></span>;<br><br>    <span class="hljs-comment">// **调用 CUDA 核函数**</span><br>    matrixMulKernel&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(d_A, d_B, d_C, N);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();  <span class="hljs-comment">// **确保计算完成**</span><br><br>    <span class="hljs-comment">// **将结果复制回主机**</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(h_C, d_C, size, cudaMemcpyDeviceToHost);<br><br>    <span class="hljs-comment">// **释放 GPU 内存**</span><br>    <span class="hljs-built_in">cudaFree</span>(d_A);<br>    <span class="hljs-built_in">cudaFree</span>(d_B);<br>    <span class="hljs-built_in">cudaFree</span>(d_C);<br>&#125;<br><br><span class="hljs-comment">// **打印矩阵**</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-type">float</span> *matrix, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j) &#123;<br>            cout &lt;&lt; matrix[i * N + j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// **主函数**</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 矩阵大小</span><br>    <span class="hljs-type">int</span> size = N * N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br><br>    <span class="hljs-comment">// **分配主机端矩阵**</span><br>    <span class="hljs-type">float</span> *h_A = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[N * N];<br>    <span class="hljs-type">float</span> *h_B = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[N * N];<br>    <span class="hljs-type">float</span> *h_C = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[N * N];<br><br>    <span class="hljs-comment">// **初始化矩阵**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N * N; i++) &#123;<br>        h_A[i] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>);<br>        h_B[i] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Matrix A:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printMatrix</span>(h_A, N);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Matrix B:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printMatrix</span>(h_B, N);<br><br>    <span class="hljs-comment">// **执行 CUDA 矩阵乘法**</span><br>    <span class="hljs-built_in">matrixMultiplication</span>(h_A, h_B, h_C, N);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Result Matrix C = A * B:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printMatrix</span>(h_C, N);<br><br>    <span class="hljs-comment">// **释放主机内存**</span><br>    <span class="hljs-keyword">delete</span>[] h_A;<br>    <span class="hljs-keyword">delete</span>[] h_B;<br>    <span class="hljs-keyword">delete</span>[] h_C;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-增加共享内存"><a href="#2-增加共享内存" class="headerlink" title="2.增加共享内存"></a>2.增加共享内存</h4><ul><li>采用共享内存进行矩阵乘法的运算<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// **共享内存的 CUDA 核函数**</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">matrixMulShared</span><span class="hljs-params">(<span class="hljs-type">float</span> *A, <span class="hljs-type">float</span> *B, <span class="hljs-type">float</span> *C, <span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-comment">// **共享内存**</span><br>    __shared__ <span class="hljs-type">float</span> Asub[BLOCK_SIZE][BLOCK_SIZE];<br>    __shared__ <span class="hljs-type">float</span> Bsub[BLOCK_SIZE][BLOCK_SIZE];<br><br>    <span class="hljs-comment">// 计算当前线程的全局索引</span><br>    <span class="hljs-type">int</span> row = blockIdx.y * BLOCK_SIZE + threadIdx.y;<br>    <span class="hljs-type">int</span> col = blockIdx.x * BLOCK_SIZE + threadIdx.x;<br><br>    <span class="hljs-type">float</span> sum = <span class="hljs-number">0.0f</span>;<br><br>    <span class="hljs-comment">// **以 BLOCK_SIZE 为单位，遍历 A 和 B 的子矩阵**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (N + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE; ++i) &#123;<br>        <span class="hljs-comment">// **加载 A 和 B 的子块到共享内存**</span><br>        <span class="hljs-keyword">if</span> (row &lt; N &amp;&amp; (i * BLOCK_SIZE + threadIdx.x) &lt; N)<br>            Asub[threadIdx.y][threadIdx.x] = A[row * N + i * BLOCK_SIZE + threadIdx.x];<br>        <span class="hljs-keyword">else</span><br>            Asub[threadIdx.y][threadIdx.x] = <span class="hljs-number">0.0f</span>;<br><br>        <span class="hljs-keyword">if</span> (col &lt; N &amp;&amp; (i * BLOCK_SIZE + threadIdx.y) &lt; N)<br>            Bsub[threadIdx.y][threadIdx.x] = B[(i * BLOCK_SIZE + threadIdx.y) * N + col];<br>        <span class="hljs-keyword">else</span><br>            Bsub[threadIdx.y][threadIdx.x] = <span class="hljs-number">0.0f</span>;<br><br>        __syncthreads();  <span class="hljs-comment">// **同步线程，确保所有线程都加载完成**</span><br><br>        <span class="hljs-comment">// **计算当前 C[row, col]**</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; BLOCK_SIZE; ++k)<br>            sum += Asub[threadIdx.y][k] * Bsub[k][threadIdx.x];<br><br>        __syncthreads();  <span class="hljs-comment">// **确保计算完成后再加载新的数据**</span><br>    &#125;<br><br>    <span class="hljs-comment">// **存储计算结果**</span><br>    <span class="hljs-keyword">if</span> (row &lt; N &amp;&amp; col &lt; N)<br>        C[row * N + col] = sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-增加共享内存"><a href="#3-增加共享内存" class="headerlink" title="3.增加共享内存"></a>3.增加共享内存</h4><p>共享内存 reduce-sum 基础版本<br>未优化的 Kernel</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduceSumNaive</span><span class="hljs-params">(<span class="hljs-type">float</span> *d_in, <span class="hljs-type">float</span> *d_out, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    __shared__ <span class="hljs-type">float</span> sharedMem[<span class="hljs-number">1024</span>];  <span class="hljs-comment">// 共享内存</span><br>    <span class="hljs-type">int</span> tid = threadIdx.x;<br>    <span class="hljs-type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;<br><br>    <span class="hljs-comment">// **加载数据到共享内存**</span><br>    <span class="hljs-keyword">if</span> (idx &lt; n)<br>        sharedMem[tid] = d_in[idx];<br>    <span class="hljs-keyword">else</span><br>        sharedMem[tid] = <span class="hljs-number">0.0f</span>;  <span class="hljs-comment">// 处理越界情况</span><br><br>    __syncthreads();  <span class="hljs-comment">// 确保所有线程都加载完成</span><br><br>    <span class="hljs-comment">// **归约求和（标准 Reduction）**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = blockDim.x / <span class="hljs-number">2</span>; s &gt; <span class="hljs-number">0</span>; s &gt;&gt;= <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// s 依次减少为 512, 256, 128, ...</span><br>        <span class="hljs-keyword">if</span> (tid &lt; s) &#123;<br>            sharedMem[tid] += sharedMem[tid + s];  <span class="hljs-comment">// 线程对数据累加</span><br>        &#125;<br>        __syncthreads();  <span class="hljs-comment">// 确保所有线程完成</span><br>    &#125;<br><br>    <span class="hljs-comment">// **将结果存回全局内存**</span><br>    <span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>) <br>        d_out[blockIdx.x] = sharedMem[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>解决 Bank Conflict：交错存储（Strided Access）</p><ul><li>调整访问模式，让不同线程访问不同的 Bank，避免 Bank Conflict。</li><li>使用对数归约（Optimized Reduction），减少线程同步次数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduceSumOptimized</span><span class="hljs-params">(<span class="hljs-type">float</span> *d_in, <span class="hljs-type">float</span> *d_out, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    __shared__ <span class="hljs-type">float</span> sharedMem[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-type">int</span> tid = threadIdx.x;<br>    <span class="hljs-type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;<br><br>    <span class="hljs-comment">// **交错存储，减少 Bank Conflict**</span><br>    <span class="hljs-keyword">if</span> (idx &lt; n)<br>        sharedMem[tid] = d_in[idx];<br>    <span class="hljs-keyword">else</span><br>        sharedMem[tid] = <span class="hljs-number">0.0f</span>;  <span class="hljs-comment">// 处理越界情况</span><br><br>    __syncthreads();<br><br>    <span class="hljs-comment">// **优化的 Reduction**</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = blockDim.x / <span class="hljs-number">2</span>; s &gt; <span class="hljs-number">0</span>; s &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (tid &lt; s) &#123;<br>            sharedMem[tid] += sharedMem[tid + s];<br>        &#125;<br>        __syncthreads();<br>    &#125;<br><br>    <span class="hljs-comment">// **存回全局内存**</span><br>    <span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br>        d_out[blockIdx.x] = sharedMem[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="解决bank冲突的常见方法"><a href="#解决bank冲突的常见方法" class="headerlink" title="解决bank冲突的常见方法"></a>解决bank冲突的常见方法</h4><ul><li>Swizzle 中采用将索引与行进行异或从而消除了存储体冲突并对齐了地址 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">half* <span class="hljs-title">row_swizzled_layout</span><span class="hljs-params">(half* data, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> address = (<span class="hljs-type">uint64_t</span>)&amp;data[r * columns + c];    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;half *&gt;(address ^ (r &lt;&lt; <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li><li>padding是Bank Conflict的常见解决方案的一种用一个存储体“填充”每一行，从而引入偏移量以将列的连续元素移动到不同的存储体中。这消除了存储体冲突，但会产生未对齐的地址，从而干扰需要对齐地址的快速指令。</li></ul>]]></content>
    
    
    <categories>
      
      <category>cuda八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能计算岗位-cuda矩阵转置</title>
    <link href="/2025/03/10/20250310/"/>
    <url>/2025/03/10/20250310/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个矩阵 <code>src</code>，输出其转置后的矩阵 <code>out</code>。<br><strong>示例</strong>:<br>输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在矩阵转置中，原矩阵中位于第 <code>i</code> 行第 <code>j</code> 列的元素，对应到转置后的矩阵中就是第 <code>j</code> 行第 <code>i</code> 列的位置。因此，通过简单地将索引对调即可完成矩阵转置。</p><p>CUDA 的实现则需要将每个线程映射到矩阵中的一个元素。具体步骤如下：</p><ol><li>每个线程获取自身的全局索引。</li><li>检查索引是否越界（确保线程对应的索引在矩阵范围内）。</li><li>根据索引计算出原矩阵元素的位置，将其写入到转置矩阵的正确位置。</li></ol><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下代码演示了一个简单的 CUDA 实现，展示了如何使用 CUDA 核函数将矩阵转置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;device_launch_parameters.h&gt;</span></span><br><br><span class="hljs-comment">// CUDA 核函数：实现矩阵转置</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">transposeKernel</span><span class="hljs-params">(<span class="hljs-type">int</span> *src, <span class="hljs-type">int</span>* out, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> tid_x = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-type">int</span> tid_y = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-keyword">if</span> (tid_x &lt; width &amp;&amp; tid_y &lt; height) &#123;<br>        <span class="hljs-type">int</span> input = tid_y * width + tid_x;<br>        <span class="hljs-type">int</span> output = tid_x * height + tid_y;<br>        out[output] = src[input];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> height = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> size = width * height * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><br>    <span class="hljs-comment">// 分配主机内存</span><br>    <span class="hljs-type">int</span> *src = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[width * height];<br>    <span class="hljs-type">int</span> *out = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[width * height];<br><br>    <span class="hljs-comment">// 分配设备内存</span><br>    <span class="hljs-type">int</span> *d_src, *d_out;<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span>**)&amp;d_src, size);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span>**)&amp;d_out, size);<br><br>    <span class="hljs-comment">// 初始化输入矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width * height; i++) &#123;<br>        src[i] = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 将数据从主机拷贝到设备</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_src, src, size, cudaMemcpyHostToDevice);<br><br>    <span class="hljs-comment">// 配置线程块和线程网格</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((width + block.x - <span class="hljs-number">1</span>) / block.x, (height + block.y - <span class="hljs-number">1</span>) / block.y)</span></span>;<br><br>    <span class="hljs-comment">// 启动CUDA核函数</span><br>    transposeKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_src, d_out, width, height);<br><br>    <span class="hljs-comment">// 将结果从设备拷贝回主机</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(out, d_out, size, cudaMemcpyDeviceToHost);<br><br>    <span class="hljs-comment">// 打印部分结果进行验证</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        std::cout &lt;&lt; out[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">delete</span>[] src;<br>    <span class="hljs-keyword">delete</span>[] out;<br>    <span class="hljs-built_in">cudaFree</span>(d_src);<br>    <span class="hljs-built_in">cudaFree</span>(d_out);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试手撕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年3月9日金山上机笔试题目</title>
    <link href="/2025/03/09/20250309%E9%87%91%E5%B1%B1%E7%AC%94%E8%AF%95/"/>
    <url>/2025/03/09/20250309%E9%87%91%E5%B1%B1%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含字母和数字的字符串 <code>str</code>，需要输出其中最长的连续数字子串。<br><strong>输入描述</strong>: 一个由字母和数字组成的字符串，长度不超过255；字符串保证至少有一个数字字符，并且只有一个最长的数字子串。<br><strong>输出描述</strong>: 最长的数字子串。<br><strong>示例</strong>:<br>输入：abcd12345ed125ss123058789<br>输出：123058789</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>利用 <code>isdigit()</code> 函数判断字符是否为数字。  </li><li>使用滑动窗口技巧，记录数字子串的起始位置及其长度。  </li><li>在遍历结束后，比较当前记录的数字子串长度和之前的最长长度，更新最长的子串。</li></ol><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是 C++ 的实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 获取最长数字子串</span><br><span class="hljs-function">string <span class="hljs-title">getMaxNumberToArray</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; src)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = src.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 最长数字子串的长度</span><br>    <span class="hljs-type">int</span> currentLength = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 当前数字子串的长度</span><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 当前数字子串的起始位置</span><br>    <span class="hljs-type">int</span> maxStart = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最长数字子串的起始位置</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">char</span> c = src[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (currentLength == <span class="hljs-number">0</span>)<br>            &#123;<br>                start = i;<br>            &#125;<br>            currentLength++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (currentLength &gt; maxLength)<br>            &#123;<br>                maxLength = currentLength;<br>                maxStart = start;<br>            &#125;<br>            currentLength = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后再检查一次当前数字子串是否是最长</span><br>    <span class="hljs-keyword">if</span> (currentLength &gt; maxLength)<br>    &#123;<br>        maxLength = currentLength;<br>        maxStart = start;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> src.<span class="hljs-built_in">substr</span>(maxStart, maxLength);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string line;<br>    <span class="hljs-built_in">getline</span>(cin,line);<br>    cout &lt;&lt; <span class="hljs-built_in">getMaxNumberToArray</span>(line) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大厂笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板</title>
    <link href="/2025/03/08/My-First-Note/"/>
    <url>/2025/03/08/My-First-Note/</url>
    
    <content type="html"><![CDATA[<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n; <span class="hljs-comment">// 我们定义target在左闭右开的区间里，[left, right)  </span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle; <span class="hljs-comment">// target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在 [middle+1, right)中</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值的情况，直接返回下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="深度优先遍历（递归）"><a href="#深度优先遍历（递归）" class="headerlink" title="深度优先遍历（递归）"></a>深度优先遍历（递归）</h4><p>前序遍历（中左右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中 ，同时也是处理节点逻辑的地方</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历（左中右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中 ，同时也是处理节点逻辑的地方</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历（左右中）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中 ，同时也是处理节点逻辑的地方</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深度优先遍历（迭代法）"><a href="#深度优先遍历（迭代法）" class="headerlink" title="深度优先遍历（迭代法）"></a>深度优先遍历（迭代法）</h4><p>相关题解：<a href="https://github.com/youngyangyang04/leetcode/blob/master/problems/0094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.md">0094.二叉树的中序遍历</a></p><p>前序遍历（中左右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>            st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);                          <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);            <span class="hljs-comment">// 节点处理逻辑</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>中序遍历（左中右）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 存放中序遍历的元素</span><br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>(); <br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>(); <br>            node = st.<span class="hljs-built_in">top</span>(); <br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);            <span class="hljs-comment">// 节点处理逻辑</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历（左右中）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);            <span class="hljs-comment">// 节点处理逻辑</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="广度优先遍历（队列）"><a href="#广度优先遍历（队列）" class="headerlink" title="广度优先遍历（队列）"></a>广度优先遍历（队列）</h4><p>相关题解：<a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">0102.二叉树的层序遍历</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    queue&lt;TreeNode*&gt; que;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()</span><br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);   <span class="hljs-comment">// 节点处理的逻辑</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(vec);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以直接解决如下题目：</p><ul><li><p><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">0102.二叉树的层序遍历</a></p></li><li><p><a href="https://github.com/youngyangyang04/leetcode/blob/master/problems/0199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE.md">0199.二叉树的右视图</a></p></li><li><p><a href="https://github.com/youngyangyang04/leetcode/blob/master/problems/0637.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC.md">0637.二叉树的层平均值</a> </p></li><li><p><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">0104.二叉树的最大深度 （迭代法）</a></p></li><li><p><a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html">0111.二叉树的最小深度（迭代法）</a></p></li><li><p><a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html">0222.完全二叉树的节点个数（迭代法）</a></p></li></ul><h4 id="二叉树深度"><a href="#二叉树深度" class="headerlink" title="二叉树深度"></a>二叉树深度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(node-&gt;left), <span class="hljs-built_in">getDepth</span>(node-&gt;right));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树节点数量"><a href="#二叉树节点数量" class="headerlink" title="二叉树节点数量"></a>二叉树节点数量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// 根据题意而定 </span><br><span class="hljs-type">int</span> father[<span class="hljs-number">1005</span>];<br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ;<br>    father[v] = u;<br>&#125;<br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大厂笔试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
